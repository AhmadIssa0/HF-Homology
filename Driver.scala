 
package ahmad.hfhomology

import spire.implicits._
import spire.math._
import java.io.File
import java.io.PrintWriter

object Driver {
  //println(SFSOverS2(-1,Vector(r"-7/2", r"-7/2", r"-7/3")).toTree)
  def projectTriangleToR2(
    pt: (Rational, Rational, Rational)): (Double, Double) = {
    val (x, y, z) = pt
    val c = 1/x + 1/y + 1/z
    ((1/z - 1/x + c).toDouble/math.sqrt(2), math.sqrt(3.0/2.0)*(1/y).toDouble)
  }

  def saveToFile(s: String, filename: String): Unit = {
    val pw = new PrintWriter(new File(filename))
    pw.write(s)
    pw.flush()
    pw.close()
  }

  def cubesMinimum(cubeCorners: Vector[(Rational, Rational, Rational)]) = {
    //println("cube corners: " + cubeCorners)
    val potentialMin = 
    for (pt1 <- cubeCorners;
      pt2 <- cubeCorners if pt1 != pt2 && pt1._1 <= pt2._1 && pt2._2 <= pt1._2 && pt2._2 >= pt1._1;
      pt3 <- cubeCorners if pt3 != pt2 && pt3 != pt1 && pt1._1 <= pt3._1 && pt2._2 <= pt3._2 &&
      pt3._3 <= pt1._3 && pt3._3 <= pt2._3 && pt3._3 >= pt2._2 && pt2._2 >= pt1._1 &&
      !cubeCorners.exists(p => p._1 > pt1._1 && p._2 > pt2._2 && p._3 > pt3._3)
    ) yield { (pt1._1, pt2._2, pt3._3) }

    //println("potential min:" + potentialMin)
    println("potential min length: " + potentialMin.length)
    //potentialMin.filterNot(pt => potentialMin.exists(pt2 => pt2 != pt && 
    //  (pt2._1 >= pt._1 && pt2._2 >= pt._2 && pt2._3 >= pt._3)))
    //  .minBy({case (x,y,z) => x+y+z})
    potentialMin.minBy({case (x,y,z) => x+y+z})
  }

  // emb should be given as image of vertices given by rows
  def satisfiesDInvariantRestraint(emb: Matrix) = {
    val qx = emb * emb.transpose

    val (diag, left, right) = qx.extendedSmithForm

    val diagEntries = Matrix(
      Vector((0 until diag.nRows).toVector.map(i => diag(i)(i)))).transpose


    def reduceModDiag(col: Matrix) = {
      col.hadamard(diagEntries, (a, b) => ((a % b) + b) % b)
      //(0 until col.length).toVector.map(i => col(i) % diagEntries(i))
    }

    def imageInCoker(col: Matrix) = {
      val colInCoker = left * col
      reduceModDiag(colInCoker)
    }

    val largestInvFac = diag(diag.nRows-1)(diag.nRows-1).toInt

    def genSubgpByCols(cols: Vector[Matrix],
      subgp: Vector[Matrix] = Vector(Matrix.zero(qx.nRows, 1))
    ): Vector[Matrix] = cols match {
      case Vector() => subgp
      case c +: cs => {
        val newSubgp = subgp.flatMap(x =>
          (0 until largestInvFac).toVector.map(i =>
            reduceModDiag(c.scaleMatrix(i) + x))
          ).distinct
        genSubgpByCols(cs, newSubgp)
      }
    }

    val qxDiag = (0 until qx.nRows).toVector.map(i => qx(i)(i))
    // Returns characteristic Ax for x in {1,-1}^n (viewed in coker Q)
    val charImage: Vector[Matrix] = 
    sequence(Vector.fill(diag.nRows)(Vector(1,-1)))
      .map(x => (emb * Matrix(Vector(x)).transpose).transpose.mat(0))
      .filter(ax => (0 until qxDiag.length)
        .forall(i => ((qxDiag(i) % 2 + 2) % 2) == ((ax(i) % 2 + 2) % 2)))
      .map(x => reduceModDiag(left * Matrix(Vector(x)).transpose))
      .distinct

    // subgroup of coker Q generated by columns of A
    val subgp = genSubgpByCols((left * emb).columns)
    charImage.filter(x => subgp.contains(x)).length == subgp.length
  }


  def toEvenCF(r: Rational): Vector[Int] = {
    require(r.denominator.abs % 2 == 0 || r.numerator.abs % 2 == 0,
      s"Either numerator or denominator must be even: $r")
    val n = (r/2).round.toInt * 2
    if (n == r) Vector(n)
    else n +: toEvenCF(1/(r - n))
  }

  def ladder(chain: Vector[Int]): IntersectionForm = {
    val n = chain.length
    var q = IntersectionForm(Vector(Vector(chain.head)))
    for (i <- 1 until n) {
      q = q.addGenerator(
        (0 until i+1).toVector.map( _ match {
          case k if k == i-1 => 1
          case k if k == i => chain(i)
          case _ => 0
        })
      )
    }

    for (i <- 0 until n) {
      q = q.addGenerator(
        (0 until n+i+1).toVector.map( _ match {
          case k if k == n+i-1 && i > 0 => 1
          case k if k == n+i => chain(i)
          case k if k == i => -chain(i) - 2 + (if (i == 0) 1 else 0)
          case _ => 0
        })
      )
    }

    q
  }

  def evenCFToLadder(cf: Vector[Int]): Vector[Int] = {
    assert(cf.forall(x => x < 0))
    cf.reverse.zipWithIndex.flatMap({ case (n, i) =>
      if (i % 2 == 0) Vector.fill(-n/2 - 1)(-2)
      else if (i == cf.length - 1) Vector(n - 1)
      else Vector(n - 2)
    }).reverse
  }

  def fracToLadder(r: Rational) = {
    ladder(evenCFToLadder(toEvenCF(r)))
  }

  def findEquivGenus() = {
    val filename = "C:/Users/Ahmad/Downloads/plantri50.tar/plantri50/out.txt"
    val folder = "C:/Users/Ahmad/Downloads/plantri50.tar/plantri50/"
    val bgs = (2 to 11).iterator.flatMap(n =>
      BlackGraph.fromPlantriFile(folder + s"out${n}.txt"))

    //println(s"${bgs.length} black graphs loaded.")

    //bgs.foreach { println _ }
    //sys.exit(1)
    import BlackGraph._

    case class SymmetricDiagram(snappyLink: Either[String, String],
      b: BlackGraph,
      edgeWeights: Vector[(DirEdge, Int)],
      symmetry: Map[Vertex, Vertex], // vertex map
      symmetryType: SymmetryType,
      symmetryInfo: String
    ) {

      override def equals(that: Any): Boolean = that match {
        case SymmetricDiagram(link, bg, ew, sym, symType, symInfo) => {
          b == bg && b.isConjugateSymmetry(edgeWeights, symmetry, ew, sym)
        }
        case _ => false
      }
    }


    var diagrams = Vector[Vector[SymmetricDiagram]]()
    var count = 0
    var tested = 0
    for (b <- bgs) {
      if (tested % 100 == 0)
        println(s"tested $tested")
      tested = tested + 1
      for (syms <- b.selfIsomorphisms().combinations(2);
        edgeWeights <- b.assignEdgeWeights(syms.map(_._2), maxCrossings = 16)
        if !b.hasNuggatory(edgeWeights)) {
        val (symType1, sym1) = syms(0)
        val (symType2, sym2) = syms(1)
        //if (b.numCrossings(edgeWeights) % 2 == 0 && b.det(edgeWeights) % 2 == 1) {
        if (b.det(edgeWeights) % 2 == 1 && BlackGraph.order(sym1) > 1 && BlackGraph.order(sym2) > 1) {
          val sig = b.signature(edgeWeights)
          if (sig <= 0) {
            val codim = -sig
            val embs = b.embeddings(edgeWeights = edgeWeights, codim = codim)
            //if (embs.forall(emb => !b.invarEmbGSig(emb, sym).contains(0))) {
            
            if (embs.forall(emb => !b.isEmbeddingInvariant(emb, sym1) || !b.isEmbeddingInvariant(emb, sym2)) &&
              embs.exists(emb => b.isEmbeddingInvariant(emb, sym1)) &&
              embs.exists(emb => b.isEmbeddingInvariant(emb, sym2))
            ) {
              val nonInvEmbs = embs.filter(emb => !b.isEmbeddingInvariant(emb, sym1) || !b.isEmbeddingInvariant(emb, sym2))
              nonInvEmbs.headOption match {
                case Some(emb) => {
                  val diagPair = syms.map({ case (symType, sym) =>
                    symType match {
                      case Intravergent(order) =>
                        SymmetricDiagram(b.identifyLink(edgeWeights), b, edgeWeights, sym, symType, s"sig ${-sig}")
                      case Transvergent(order) => {
                        val (periodicOrSI, linking) = b.transvergentSymmetryInfo(sym, edgeWeights)
                        SymmetricDiagram(b.identifyLink(edgeWeights),
                          b, edgeWeights, sym, symType,
                          s"$periodicOrSI, axis linking $linking, sig ${-sig}")
                      }
                    }
                  })

                  if (!diagrams.contains(diagPair)) {
                    diagrams = diagrams :+ diagPair
                    println(diagPair)
                    println(emb)
                    println(s"int form: ${b.toLaplaceMatrix(edgeWeights)}")
                    count += 1
                  }
                }
                case None =>
              }
            }
          }
        }
      }
    }
    //diagrams.foreach { println _ }
    val diagramsByKnot = diagrams.groupBy(_(0).snappyLink)
    diagramsByKnot.keys.foreach { key =>
      println(s"New knot: $key:")
      for (diags <- diagramsByKnot(key)) {
        println(s"New case $key")
        for (symmDiag <- diags) {
          println(s"graph: ${symmDiag.b}")
          println(s"${symmDiag.symmetryType}, ${symmDiag.symmetry}, ${symmDiag.edgeWeights}, ${symmDiag.symmetryInfo}")
          println("")
        }
      }
      println("")
    }
    println(s"total found: $count")
    println(s"distinct knots: ${diagramsByKnot.size}")
  }

  def possiblySNA(dinvs: Vector[Rational]): Boolean = {
    if (dinvs.length % 4 != 1) false
    else {
      dinvs.forall({ d =>
        val c = dinvs.count(_ == d)
        if (d == 0) {
          c % 4 == 1
        } else {
          c % 2 == 0 && dinvs.count(_ == -d) == c
        }
      })
    }
  }

  def SNAObstruction() = {
    // 2-bridge knots, d-invariant SNA obstruction.
    for (p <- 3 to 15 by 2;
      q <- 1 to p if gcd(p, q) == 1) {      
      val dinvs = LensSpace.dInvariants(p,q)
      //if (possiblySNA(dinvs))
        println(s"${Rational(p,q)} ${possiblySNA(dinvs)}, ${dinvs}")
    }
  }

  def main(args: Array[String]): Unit = {
    //TriangleGUI.run()
    //sys.exit(0)
    val td = TriangleData.loadFromFiles("3fib_150_has_emb.txt", "3fib_150_no_emb.txt")
    //val td2 = TriangleData.loadFromFiles("3fib_120_has_emb_r3.txt", "3fib_no_emb_100.txt")
    val knownNonEmb =  td.nonEmbPts //++ td2.nonEmbPts
    val knownEmb = td.embPts.zip(td.codims)
    import scala.io.Source
    val skipped = Source.fromFile("3fib_150_skipped.txt")
      .getLines()
      .toVector
      .map(line => line.split(",").map(Rational(_)))
      .map(vec => (vec(0), vec(1), vec(2)))
    TriangleData.generate(knownEmb, knownNonEmb, skipped)
    //val sffff = SFSOverS2(-3, Vector(r"-2",r"-2",r"-2"))
    //val qsf = sffff.toPlanarGraph.dualGraph.toIntersectionForm.directSum(sffff.toTree.toIntersectionForm)
    //qsf.complementaryEmbeddings.foreach { println }
    //.complementaryEmbsWithPartitions.foreach { println }
    //println(LensSpace.dInvariants(8,3))
    //SNAObstruction()
    sys.exit(0)
    /*
    val qint = IntersectionForm ( // 12a_1105
      Vector(
        Vector(-3,1,0,0,1,1),
        Vector(1,-3,1,0,0,0),
        Vector(0,1,-4,2,0,0),
        Vector(0,0,2,-4,1,0),
        Vector(1,0,0,1,-3,0),
        Vector(1,0,0,0,0,-2)))
     */
    /*

    val mss = Matrix(
      Vector(Vector( -1, -1, -1, 0, -1, -1, 0, 0), Vector( 0, 1, 0, -1, 0, 1, 0, 0), Vector( 0, -1, -1, 0, -1, -1, -1, 0), Vector( 0, 0, 0, -1, 0, 0, 0, 0), Vector( 0, -1, 0, 0, -1, -1, -1, 0), Vector( 0, 0, 0, 0, 0, 1, 0, 0), Vector( 0, 1, 0, -1, 0, 1, 1, 0), Vector( -1, 0, -1, 0, 0, 0, 0, 1))
    )

    println((mss + mss.transpose).invariantFactors)
    sys.exit(0)
     */

    /*
    Intersection ( // 12a_1105
      Vector(
        Vector(-3,1,0,0,1,1),
        Vector(1,-3,1,0,0,0),
        Vector(0,1,-4,2,0,0),
        Vector(0,0,2,-4,1,0),
        Vector(1,0,0,1,-3,0),
        Vector(1,0,0,0,0,-2)))
    */

    /* IntersectionForm(// 12a_819
     Vector(Vector(-5,1,0,0,0,1),
Vector(1,-3,1,0,0,0),
Vector(0,1,-2,1,0,0),
Vector(0,0,1,-2,1,0),
Vector(0,0,0,1,-3,1),
Vector(1,0,0,0,1,-3)))

     */

    /*
     IntersectionForm( // 12a_458
Vector(Vector(-3,1,0,0,1,0),
     Vector(1,-4,1,1,0,0),
     Vector(0,1,-4,1,1,0),
     Vector(0,1,1,-2,0,0),
     Vector(1,0,1,0,-3,1),
     Vector(0,0,0,0,1,-3)))

     */
/*
    IntersectionForm(Vector( // 10_99
      Vector(-3,1,0,0,1),
      Vector(1,-2,1,0,0),
      Vector(0,1,-4,1,0),
      Vector(0,0,1,-4,1),
      Vector(1,0,0,1,-2)))
*/


/*
    IntersectionForm(Vector( // 10_123
      Vector(-5,1,1,1,1),
      Vector(1,-3,1,0,0),
      Vector(1,1,-3,1,0),
      Vector(1,0,1,-3,1),
      Vector(1,0,0,1,-3)))
 */


    

    val emb11 = Matrix( // 12a_1105
     Vector(Vector(1,0,0,0,-1,1,0,0,0,0,0,0),
     Vector(-1,1,0,0,0,0,0,1,0,0,0,0),
     Vector(0,-1,1,0,0,0,0,0,1,0,0,1),
     Vector(0,0,-1,1,0,0,0,0,0,1,0,-1),
     Vector(0,0,0,-1,1,0,0,0,0,0,1,0),
     Vector(0,0,0,0,0,-1,1,0,0,0,0,0)))

    /*Matrix(Vector(Vector(1,0,0,0,0,0,0,0,-1,1,0,0), //12a1202
Vector(-1,1,0,0,0,0,0,0,0,0,0,0),
Vector(0,-1,1,1,1,0,0,0,0,0,0,1),
Vector(0,0,-1,-1,0,1,1,1,0,0,0,0),
Vector(0,0,0,0,0,0,0,-1,1,0,0,0),
Vector(0,0,0,0,0,0,0,0,0,-1,1,0)))
     */
    /*Matrix( // 12a_1105
     Vector(Vector(1,0,0,0,-1,1,0,0,0,0,0,0),
     Vector(-1,1,0,0,0,0,0,1,0,0,0,0),
     Vector(0,-1,1,0,0,0,0,0,1,0,0,1),
     Vector(0,0,-1,1,0,0,0,0,0,1,0,-1),
     Vector(0,0,0,-1,1,0,0,0,0,0,1,0),
     Vector(0,0,0,0,0,-1,1,0,0,0,0,0)))
     */

    /* Matrix( // 12a_1105
     Vector(Vector(1,0,0,0,-1,1,0,0,0,0,0,0),
     Vector(-1,1,0,0,0,0,0,1,0,0,0,0),
     Vector(0,-1,1,0,0,0,0,0,1,0,0,1),
     Vector(0,0,-1,1,0,0,0,0,0,1,0,-1),
     Vector(0,0,0,-1,1,0,0,0,0,0,1,0),
     Vector(0,0,0,0,0,-1,1,0,0,0,0,0)))
     */
    /* Matrix( // 12a_458
     Vector(Vector(1,0,0,0,1,0,1,0,0,0,0,0),
Vector(-1,1,0,0,0,0,0,1,0,0,0,1),
Vector(0,0,-1,1,0,0,0,0,1,0,0,-1),
Vector(0,-1,1,0,0,0,0,0,0,0,0,0),
Vector(0,0,0,-1,-1,1,0,0,0,0,0,0),
Vector(0,0,0,0,0,-1,0,0,0,1,1,0)))

     */

    /*Matrix( // 10_99
Vector(Vector(1,0,0,0,-1,1,0,0,0,0),
Vector(-1,1,0,0,0,0,0,0,0,0),
Vector(0,-1,1,0,0,0,1,1,0,0),
Vector(0,0,-1,1,0,0,0,0,1,1),
Vector(0,0,0,-1,1,0,0,0,0,0))
    )*/

    /*Matrix(Vector(Vector(0,1,1,1,1,1,0,0,0,0), // 10_123
Vector(1,-1,0,0,0,0,1,0,0,0),
Vector(0,0,0,-1,0,0,-1,1,0,0),
Vector(0,0,0,0,-1,0,0,-1,1,0),
Vector(0,0,0,0,0,-1,0,0,-1,1)))*/


    val emb22 = Matrix( // 12a_1105
     Vector(Vector(0,0,0,0,0,0,0,0,-1,1,0,1),
     Vector(0,1,0,0,0,0,0,-1,1,0,0,0),
     Vector(1,0,0,0,0,-1,-1,1,0,0,0,0),
     Vector(0,0,0,0,1,1,1,0,0,0,-1,0),
     Vector(0,0,0,1,0,0,0,0,0,-1,1,0),
       Vector(0,0,1,0,0,0,0,0,0,0,0,-1)))

    /*Matrix( //12a1202
Vector(Vector(0,0,0,1,-1,1,0,0,0,0,0,0),
Vector(0,0,0,0,1,0,0,0,0,0,0,-1),
Vector(1,1,0,0,0,0,0,0,0,-1,-1,1),
Vector(0,0,0,0,0,0,-1,1,1,1,1,0),
Vector(0,0,0,0,0,-1,1,0,0,0,0,0),
Vector(0,0,1,-1,0,0,0,0,0,0,0,0))
    )*/

    println(s"int? ${emb11 * emb11.transpose}")
    println(s"int? ${emb22 * emb22.transpose}")
    println((emb22 * emb22.transpose).invariantFactors)

    val qint = IntersectionForm((emb11 * emb11.transpose * -1).toIntVector)
    /*
    Matrix( // 12a_1105
     Vector(Vector(0,0,0,0,0,0,0,0,-1,1,0,1),
     Vector(0,1,0,0,0,0,0,-1,1,0,0,0),
     Vector(1,0,0,0,0,-1,-1,1,0,0,0,0),
     Vector(0,0,0,0,1,1,1,0,0,0,-1,0),
     Vector(0,0,0,1,0,0,0,0,0,-1,1,0),
       Vector(0,0,1,0,0,0,0,0,0,0,0,-1)))
    */

    /* Matrix( //12a_458
     Vector(Vector(-1,0,0,0,0,0,1,-1,0,0,0,0),
Vector(0,0,0,0,1,1,-1,0,0,0,1,0),
Vector(0,0,0,-1,0,-1,0,0,1,-1,0,0),
Vector(0,0,0,0,0,0,0,0,0,1,-1,0),
Vector(0,0,0,0,0,0,0,1,-1,0,0,-1),
Vector(0,-1,-1,0,0,0,0,0,0,0,0,1)))

     */

    """Matrix( // 10_99
Vector(Vector(0,0,1,0,0,0,0,-1,1,0),
Vector(0,0,0,0,0,0,-1,1,0,0),
Vector(1,1,0,0,0,-1,1,0,0,0),
Vector(0,0,0,1,1,1,0,0,0,-1),
Vector(0,0,0,0,0,0,0,0,-1,1))
    )"""

    """Matrix(Vector(Vector(-1,0,0,0,0,0,1,1,1,1), // 10_123
Vector(0,0,1,0,0,-1,0,0,0,-1),
Vector(0,0,0,0,-1,1,0,0,-1,0),
Vector(0,0,0,-1,1,0,0,-1,0,0),
Vector(0,-1,0,1,0,0,-1,0,0,0)))"""

    val as = AmphicheiralSymmetry(qint.toMatrix, emb11, emb22)

    println(s"emb11 = ${emb11}")
    println(s"emb22 = ${emb22}")
    println(s"u = ${as.u}")
    println(s"d = ${as.d}")
    as.orbits.foreach { println }
    //val spincy = Matrix(Vector(Vector(1,0,0,0,2))).transpose
    //println(as.rho(Matrix(Vector(Vector(1,0,0,18,10))).transpose))

    
    //println(as.normalizeSpincY(as.left * emb11 * as.pullback(as.leftInv * spincy, emb11)))
    //println(s"pullback: ${as.pullback(as.leftInv * spincy, emb11)}")

    """
    IntersectionForm(Vector(
      Vector(-5,1,1,1,1),
      Vector(1,-3,1,0,0),
      Vector(1,1,-3,1,0),
      Vector(1,0,1,-3,1),
      Vector(1,0,0,1,-3)))
    """
    println(qint.det)
    val embsm = qint.embeddingsAsMatrices(Some(qint.rank))
    println(s"${embsm.length} lattice embeddings")
    embsm.foreach { println }


    println(s"Good basis is in L Spin^c(Y). L = ${as.left}")
    println("spinc which extend")
    as.spincYExtending(embsm(0)).foreach { println }
    println("spinc which extend (old basis)")
    as.spincYExtending(embsm(0)).foreach { s => println(as.spincYToOldBasis(s)) }
    for (i <- 0 until embsm.length) {
      println(s"Spinc rho eq? ${as.isRhoInvariant(as.spincYExtending(embsm(i)))}")
    }
    println(s"q = ${as.q}")
    val secondvec = Matrix(Vector(Vector(3, -3, 2, 0, -1, -2))).transpose
    println(s"Pullback of 2nd vector: ${as.pullback(secondvec, emb11)}")
    sys.exit(0)
   //println(qint.extendedSmithForm)

    val vint = Matrix(Vector(Vector(0,1,1,1,1,1,0,0,0,0),
Vector(1,-1,0,0,0,0,1,0,0,0),
Vector(0,0,0,-1,0,0,-1,1,0,0),
Vector(0,0,0,0,-1,0,0,-1,1,0),
      Vector(0,0,0,0,0,-1,0,0,-1,1)))
    println(vint.extendedSmithForm)
    sys.exit(0)
    val nn = 3
    val mont2 = SFSOverS2(-3, Vector(Rational(-nn,nn-1), Rational(-(2*nn+2), 1), Rational(-nn,nn-1)))
    //println(mont2.homologyOrder)
    val embz = mont2.toTree.toIntersectionForm.embeddingsAsMatrices(Some(2*(nn-1)+2+2))
    println(mont2.toTree.toIntersectionForm)

    def interc(mat: Matrix) = {
      Matrix((0 until mat.nRows).toVector.map({ i =>
        if (i == 0) mat.mat(3)
        else if (i == 1) mat.mat(4)
        else if (i == 3) mat.mat(0)
        else if (i == 4) mat.mat(1)
        else mat.mat(i)
      }))
    }

    for (i <- 0 until embz.length) {
      //if (embz.take(i).forall(e => !LatticeEmbedding.equivEmbeddings(embz(i), e)))
      //  println(embz(i))
      if (LatticeEmbedding.equivEmbeddings(embz(i), interc(embz(i))))
        println(embz(i))
    }


    sys.exit(0)

    val q40 = IntersectionForm(Vector(
      Vector(-4,1,1,1),
      Vector(1,-3,1,0),
      Vector(1,1,-4,1),
      Vector(1,0,1,-3)))
    
    
    //val embk = q40.embeddingsAsMatrices(Some(q40.rank + 2))
    //embk.foreach { println }
    //sys.exit(1)

    val emb5 = Matrix(Vector(Vector(1,-1,-1,1,0,0),
      Vector(0,0,0,-1,1,1),
      Vector(-1,1,-1,0,-1,0),
      Vector(1,1,1,0,0,0)))
    val emb6 = Matrix(Vector(Vector(-1,1,-1,0,-1,0),
      Vector(0,0,0,-1,1,1),
      Vector(1,-1,-1,1,0,0),
      Vector(1,1,1,0,0,0)))
    println(LatticeEmbedding.equivEmbeddings(emb5, emb6))
    println(LatticeEmbedding.embeddingEquivs(emb5, emb6))
    println(LatticeEmbedding.gSignatures(emb5, emb6))
    
    //sys.exit(1)
    //println(toEvenCF(r"25/16"))
    //sys.exit(1)
    //println(ladder(Vector(-3,-2,-8)))

    //val bg = BlackGraph(Map(("a", Vector("b")), ("b", Vector("a"))))
    val bg = BlackGraph(Map(
      /*
      ("a", "be".split("").toVector),
      ("b", "ae".split("").toVector),
      ("c", "ed".split("").toVector),
      ("d", "ce".split("").toVector),
      ("e", "adcb".split("").toVector)
       */
      ("a", "bc".split("").toVector),
      ("b", "ca".split("").toVector),
      ("c", "ab".split("").toVector)
      /*
      ("a", "bcde".split("").toVector),
      ("b", "eca".split("").toVector),
      ("c", "dabe".split("").toVector),
      ("d", "ace".split("").toVector),
      ("e", "badc".split("").toVector)
       */
    ))
    //println(bg.isomorphismsTo(bg))
    //println(bg.mirror)
    println(MultiGraph.fromBlackGraph(bg, Vector((("a", "b"), 2))).signature)
    println(bg.det(Vector((("a", "b"), 2))))
    val mbg = MultiGraph.fromBlackGraph(bg, Vector())
    //println(mbg.toPD)
    //println(mbg.orientLink)
    println(bg.identifyLink(Vector((("a", "b"), 2))))

    println(mbg.numPositiveCrossings(mbg.orientLink))
    //sys.exit(1)
    /*
    val isos = bg.isomorphismsTo(bg)
    val iso = isos(1).toMap


    println(isos)
    println(iso)
    def manOf[T: Manifest](t: T): Manifest[T] = manifest[T]
    println(manOf(iso))
    println(bg.toLaplaceMatrix)
    val edgeWeights = Vector((("e", "b"), 2), (("e", "d"), 2))
    println(bg.assignEdgeWeights(iso, 2))
    println(s"emb: ${bg.invEmbeddings(isos(0), edgeWeights=edgeWeights, codim=0)}")
    println(s"inv emb: ${bg.invEmbeddings(iso, edgeWeights=edgeWeights, codim=0)}")
     */

    //println(bg.assignEdgeWeights(iso, 2))
    /*
    val bg2 = BlackGraph.fromPlantri("5 b,ac,bd,ce,d")
    println(BlackGraph.fromPlantri("5 b,ac,bd,ce,d"))
    println(bg2.isomorphismsTo(bg2))
    println(bg2.toIntersectionForm)
     */

    val filename = "C:/Users/Ahmad/Downloads/plantri50.tar/plantri50/out.txt"
    val folder = "C:/Users/Ahmad/Downloads/plantri50.tar/plantri50/"
    val bgs = (2 to 11).iterator.flatMap(n =>
      BlackGraph.fromPlantriFile(folder + s"out${n}.txt"))

    //println(s"${bgs.length} black graphs loaded.")

    //bgs.foreach { println _ }
    //sys.exit(1)
    import BlackGraph._

    case class SymmetricDiagram(snappyLink: Either[String, String],
      b: BlackGraph,
      edgeWeights: Vector[(DirEdge, Int)],
      symmetry: Map[Vertex, Vertex], // vertex map
      symmetryType: SymmetryType,
      symmetryInfo: String
    ) {

      override def equals(that: Any): Boolean = that match {
        case SymmetricDiagram(link, bg, ew, sym, symType, symInfo) => {
          b == bg && b.isConjugateSymmetry(edgeWeights, symmetry, ew, sym)
        }
        case _ => false
      }
    }


    var diagrams = Vector[SymmetricDiagram]()
    var count = 0
    var tested = 0
    for (b <- bgs) {
      if (tested % 100 == 0)
        println(s"tested $tested")
      tested = tested + 1
      for ((symType, sym) <- b.selfIsomorphisms();
        edgeWeights <- b.assignEdgeWeights(Vector(sym), maxCrossings = 11)
        if !b.hasNuggatory(edgeWeights)) {
        //if (b.numCrossings(edgeWeights) % 2 == 0 && b.det(edgeWeights) % 2 == 1) {
        if (b.det(edgeWeights) % 2 == 1 && BlackGraph.order(sym) > 1) {
        //  val sig = b.signature(edgeWeights)
          /*
          if (sig == 0 && !b.embeddings(edgeWeights = edgeWeights, codim = 0).isEmpty) {
            val diag = SymmetricDiagram(b.identifyLink(edgeWeights),
              b, edgeWeights, sym, symType)
            if (!diagrams.contains(diag)) {
              diagrams = diagrams :+ diag
              count += 1
            }
          }
          */
          symType match {
            case Intravergent(order) => {
              //println(s"$b, $sym, $symType, ${b.identifyLink(edgeWeights)}")
              // START COMMENT
              val sig = b.signature(edgeWeights)
              if (sig <= 0) {
                val codim = -sig
                val embs = b.embeddings(edgeWeights = edgeWeights, codim = codim)
                //if (embs.forall(emb => !b.invarEmbGSig(emb, sym).contains(0))) {
                if (embs.forall(emb => !b.isEmbeddingInvariant(emb, sym))) {

                  embs.filter(emb => !b.isEmbeddingInvariant(emb, sym)).headOption match {
                    case Some(emb) => {
                      // G-signature obstruction
                      /*
                      if (embs.exists(emb => b.isEmbeddingInvariant(emb, sym))) {
                        println("G-sig obstructs")
                        println(b)
                        println(sym)
                        println(SymmetricDiagram(b.identifyLink(edgeWeights),
                          b, edgeWeights, sym, symType, ""))
                        println(s"signature: $sig")
                        embs.filter(b.isEmbeddingInvariant(_, sym)).foreach { println }
                      }*/
                      if (order > 1) {
                        val diag = SymmetricDiagram(b.identifyLink(edgeWeights),
                          b, edgeWeights, sym, symType, s"sig ${-sig}")
                        if (!diagrams.contains(diag)) {
                          diagrams = diagrams :+ diag
                          count += 1
                        }
                      }
                    }
                    case None =>
                  }
                }
              } // END COMMENT
              /*
              if (order > 1) {
                val diag = SymmetricDiagram(b.identifyLink(edgeWeights),
                  b, edgeWeights, sym, symType)
                if (!diagrams.contains(diag)) {
                  diagrams = diagrams :+ diag
                  count += 1
                }
              }*/
            }
            case Transvergent(order) => {
              val sig = b.signature(edgeWeights)
              if (sig <= 0) {
                val codim = -sig
                val embs = b.embeddings(edgeWeights = edgeWeights, codim = codim)
                //if (embs.forall(emb => !b.invarEmbGSig(emb, sym).contains(0))) {
                if (embs.forall(emb => !b.isEmbeddingInvariant(emb, sym))) {

                  embs.filter(emb => !b.isEmbeddingInvariant(emb, sym)).headOption match {
                    case Some(emb) => {
                      // G-signature obstruction
                      /*
                      if (embs.exists(emb => b.isEmbeddingInvariant(emb, sym))) {
                        println("G-sig obstructs")
                        println(b)
                        println(sym)
                        println(SymmetricDiagram(b.identifyLink(edgeWeights),
                          b, edgeWeights, sym, symType, ""))
                        println(s"signature: $sig")
                        embs.filter(b.isEmbeddingInvariant(_, sym)).foreach { println }
                      }*/
                      if (order > 1) {
                        val (periodicOrSI, linking) = b.transvergentSymmetryInfo(sym, edgeWeights)
                        val diag = SymmetricDiagram(b.identifyLink(edgeWeights),
                          b, edgeWeights, sym, symType,
                          s"$periodicOrSI, axis linking $linking, sig ${-sig}")
                        if (!diagrams.contains(diag)) {
                          diagrams = diagrams :+ diag
                          count += 1
                        }
                      }
                    }
                    case None =>
                  }
                }
              }
            }
          }
        }
      }
    }
    //diagrams.foreach { println _ }
    val diagramsByKnot = diagrams.groupBy(_.snappyLink)
    diagramsByKnot.keys.foreach { key =>
      println(s"New knot: $key:")
      val byBG = diagramsByKnot(key).groupBy(_.b)
      byBG.keys.foreach { bg =>
        println(s"$key")
        println(s"graph: $bg")
        byBG(bg).foreach { symmDiag =>
          println(s"${symmDiag.symmetryType}, ${symmDiag.symmetry}, ${symmDiag.edgeWeights}, ${symmDiag.symmetryInfo}")
        }
        println("")
      }
      println("")
    }
    println(s"total found: $count")
    println(s"distinct knots: ${diagramsByKnot.size}")

    /*
    var knotTypes = Vector[(Either[String, String], SymmetryType)]()
    
    for (b <- bgs) {
      for ((symType, sym) <- b.selfIsomorphisms();
        edgeWeights <- b.assignEdgeWeights(sym, maxCrossings = 12)) {
        val sig = b.signature(edgeWeights)
        if (sig <= 0 && b.det(edgeWeights) % 2 == 1) {
          val codim = -sig
          val embs = b.embeddings(edgeWeights = edgeWeights, codim = codim)
          if (embs.forall(emb => !b.isEmbeddingInvariant(emb, sym))) {
            embs.filter(emb => !b.isEmbeddingInvariant(emb, sym)).headOption match {
              case Some(emb) => {
                println(s"${b.edges.length}, ${b.det(edgeWeights)}, $b, $sym, codim=$codim, $symType")
                println(edgeWeights)
                //println(b.edgeClasses(sym))
                val knot = (b.identifyLink(edgeWeights), symType)
                println(knot)
                if (!knotTypes.contains(knot))
                  knotTypes = knotTypes :+ knot
                //println(s"$emb")
              }
              case None =>
            }
          }
        }
      }
    }
    knotTypes.foreach { println _ }
     */
    //println(bgs(0))
    sys.exit(1)

    import Tree.{rationalChain => rat, tree => t}
    val tree = rat(r"-163/44")
    //val q = tree.toIntersectionForm
    //val q3 = q.directSum(q)
    val q3 = IntersectionForm(Vector(
      Vector(-4,1,1,1),
      Vector(1,-3,1,0),
      Vector(1,1,-4,1),
      Vector(1,0,1,-3)))
    println(tree)
    
    val emb1 = q3.embeddingsAsMatrices(Some(q3.rank + 2)).head
    val emb2 = emb1.switchHalves
    println(emb1)
    println(emb2)
    println(q3.embeddings(q3.rank + 2).length)
    println(LatticeEmbedding.equivEmbeddings(emb1, emb2))

    val emb3 = Matrix(Vector(Vector(1,-1,-1,1,0,0),
Vector(0,0,0,-1,1,1),
Vector(-1,1,-1,0,-1,0),
      Vector(1,1,1,0,0,0)))
    println(LatticeEmbedding.equivEmbeddings(emb1, emb3))
    println(LatticeEmbedding.equivEmbeddings(emb2, emb3))
    sys.exit(1)

    println(toEvenCF(r"-169/38"))
    println(evenCFToLadder(toEvenCF(r"-169/38")))
    println(ladder(evenCFToLadder(toEvenCF(r"-169/38"))))
    println(fracToLadder(r"-169/38"))

    println(toEvenCF(r"-49/20"))
    sys.exit(1)
    for (p <- 3 to 200 if p % 2 == 1;
      q <- 1 until p if q % 2 == 0) {
      if (toEvenCF(Rational(-p, q)).forall(_ < 0)) {
        val r = Rational(-p, q)
        val lattice = fracToLadder(r)
        val codim0 = lattice.embeddingsAsMatrices(Some(lattice.rank))
        if (!codim0.isEmpty)
          println(toEvenCF(r))

        if (!codim0.isEmpty && codim0.exists(emb => !LatticeEmbedding.equivEmbeddings(emb, emb.switchHalves))) {
          println(s"${Rational(-p, q)}, ${toEvenCF(Rational(-p, q))}")
          println(lattice)
          println(codim0.head)
        }
      }

    }

    sys.exit(1)

    val embs = q3.embeddingsAsMatrices(Some(q3.rank + 4))
    println(embs.filter(emb => LatticeEmbedding.equivEmbeddings(emb, emb.switchHalves)).length)
    
    val sfss0 = SFSOverS2.generateSFSs(fibers=1, 100, e0=4)
    for (sfs <- sfss0 if sfs.homologyOrder % 2 == 1) {
      val q1 = sfs.negDef.toTree.toIntersectionForm
      val q2 = q1.directSum(q1)
      if (q1.muBar(0) == -2 && q1.embeddings(q1.rank + 2).isEmpty && q2.embeddings(q2.rank + 3).isEmpty && !q2.embeddings(q2.rank + 4).isEmpty) {
        //println(sfs)
        //println(q2)
        //println(q2.embeddings(q2.rank + 2).head)
        //println(q2.embeddingsAsMatrices(Some(q2.rank + 4)).head)
        val embs = q2.embeddingsAsMatrices(Some(q2.rank + 4))
        //println(s"num embs: ${embs.length}")
        val invEmb = embs
          .filter(emb => LatticeEmbedding.equivEmbeddings(emb, emb.switchHalves))
        //println(s"inv embs: ${invEmb.length}")
        if (invEmb.length == 0) {
          println(sfs)
          println(sfs.toTree)
          println(s"num embs: ${embs.length}")
          println(s"inv embs: ${invEmb.length}")
          println(s"char sublinks: ${Spin.charSublinks(Matrix(q1.q))}")
          println(s"mu bar: ${q1.muBar}")
          //println(q1)
          //println(s"emb: ${embs.head}")
          //println(s"inv emb switched: ${embs.head.switchHalves}")
          //println(s"int form: $q1")
          //val emb = embs.head
          //LatticeEmbedding.equivEmbeddings(emb, emb.switchHalves, true)
        }
        
      }
      //if (sfs1.e0 == -1 && !hasCodim0 && !q1.embeddings().isEmpty) println(sfs1)
    }

    //val q1 = sfs1.negDef.toTree.toIntersectionForm
    //println(q1.embeddings)
    //println(sfs1.negDef.toPlanarGraph.dualGraph.toIntersectionForm)
      //println(sfs1.homology)
      /*
    for (
         sfs2 <- sfss0) {
      val q1 = sfs1.negDef.toTree.toIntersectionForm
      val q2 = sfs2.negDef.toPlanarGraph.dualGraph.toIntersectionForm

      if (q1.codim0Embeddings.isEmpty && q2.codim0Embeddings.isEmpty) {
        val q = q1.directSum(q2)
        val embs = q.codim0Embeddings
        if (!embs.isEmpty) {
          println(s"${sfs1} # ${sfs2}")
        }
      }
    }*/
    sys.exit(0)
    //val tree = t(-2, rat(r"-2"), rat(r"-3"), t(-2, rat(r"-2"), rat(r"-11/7")))
    /*
    val tree = rat(r"-144/55")
    println(tree.toIntersectionForm)
    val sss = SFSOverS2(-3, Vector(r"-3", r"-3", r"-3/2"))
    println(s"homology: ${sss.homology}")

    //val intform = ladder(Vector(-5,-6,-2))
    val intform = IntersectionForm(Vector(
      Vector(-3,1,0,0,0,2),
      Vector(1,-3,1,0,0,0),
      Vector(0,1,-5,2,0,2),
      Vector(0,0,2,-3,1,0),
      Vector(0,0,0,1,-3,1),
      Vector(2,0,2,0,1,-5)))

    println("embeddings")
    intform.embeddingsAsMatrices(Some(intform.rank)).foreach { println }
    println("end embeddings")
    //println(Matrix(Vector(Vector(-3,1,0,0,1),Vector(1,-3,1,0,0),Vector(0,1,-3,1,0),Vector(0,0,1,-3,1),Vector(1,0,0,1,-3))).invariantFactors)
    println(s"inv factors ${intform.toMatrix.invariantFactors}")
    
    

    println(intform.complementaryEmbeddings)
    println(intform.det)
    //println(tree.latticeEmbeddings(Some(tree.numVertices)))

    val emb1 = Matrix(Vector(Vector(-1,0,1,-1,0,0),Vector(0,1,-1,0,0,1),Vector(0,-1,-1,-1,1,-1),Vector(1,1,1,0,0,0),Vector(-1,0,0,1,1,0),Vector(1,-1,0,1,-1,1)))
    val emb2 = Matrix(Vector(Vector(1,1,1,0,0,0),Vector(-1,0,0,1,1,0),Vector(1,-1,0,1,-1,1),Vector(-1,0,1,-1,0,0),Vector(0,1,-1,0,0,1),Vector(0,-1,-1,-1,1,-1)))
    println(emb1.adjoin(emb2).isSurjective)

    val (d, ell, are) = intform.toMatrix.extendedSmithForm
    println(d)
    println(s"reduced ${ell * emb1 * are}")
    println(ell * emb2 * are)
    println(toEvenCF(r"25/18"))

    
    for (i <- 1 to 4; j <- 1 to 4; k <- 1 to 4; m <- 1 to 4) {
      val r = Rational(2*i) + Rational(1)/(2*j + 1/(Rational(2*k) + Rational(1, 2*m)))
      val t1 = rat(-r)
      val t2 = rat(-1/(1-1/r))
      //println((-r,1/(1-1/r)))
      if (! t1.latticeEmbeddings(Some(t1.numVertices)).isEmpty &&
          ! t2.latticeEmbeddings(Some(t2.numVertices)).isEmpty)
        println((r,2*i,2*j,2*k,2*m))
    }
     
    sys.exit(0)
    */

    //TriangleGUI.run()
    
    /*
            for (a1 <- 2 to 8;
      b1 <- 1 until a1 if gcd(a1, b1) == 1;
      a2 <- 2 to 8;
      b2 <- 1 until a2 if gcd(a2, b2) == 1 && a1*b2 >= a2*b1;
      a3 <- 2 to 8;
      b3 <- 1 until a3 if gcd(a3, b3) == 1 && a2*b3 >= a3*b2
      //;a4 <- 2 to 8;
      //b4 <- 1 until a4 if gcd(a4, b4) == 1 && a3*b4 >= a4*b3
      //;a5 <- 2 to 8;
      //b5 <- 1 until a5 if gcd(a5, b5) == 1 && a4*b5 >= a5*b4
            ) {

      val r1 = Rational(-a1, b1)
      val r2 = Rational(-a2, b2)
      val r3 = Rational(-a3, b3)
      //val r4 = Rational(-a4, b4)
      //val r5 = Rational(-a5, b5)
      //println(s"r1=$r1, r2=$r2, r3=$r3")
              val sfs: SFSOverS2 = SFSOverS2(-2, Vector(r1, r2, r3))
              if (sfs.isLSpace && !sfs.isQA) println(sfs)
            }
    sys.exit(0)
        for (a1 <- 2 to 8;
      b1 <- 1 until a1 if gcd(a1, b1) == 1;
      a2 <- 2 to 8;
      b2 <- 1 until a2 if gcd(a2, b2) == 1 && a1*b2 >= a2*b1;
      a3 <- 2 to 8;
      b3 <- 1 until a3 if gcd(a3, b3) == 1 && a2*b3 >= a3*b2
      //;a4 <- 2 to 8;
      //b4 <- 1 until a4 if gcd(a4, b4) == 1 && a3*b4 >= a4*b3
      //;a5 <- 2 to 8;
      //b5 <- 1 until a5 if gcd(a5, b5) == 1 && a4*b5 >= a5*b4
    ) {

      val r1 = Rational(-a1, b1)
      val r2 = Rational(-a2, b2)
      val r3 = Rational(-a3, b3)
      //val r4 = Rational(-a4, b4)
      //val r5 = Rational(-a5, b5)
      //println(s"r1=$r1, r2=$r2, r3=$r3")
      val sfs: SFSOverS2 = SFSOverS2(-3, Vector(r1, r2, r3))
      
      //println(s"orig graph: ${sfs.toPlanarGraph}")
      //println(s"dual graph: ${sfs.toPlanarGraph.dualGraph}")
      val q1 = sfs.toPlanarGraph.dualGraph.toIntersectionForm
    //println(q1)
    //println(q)
    val q2 = sfs.toTree.toIntersectionForm
      val q = q2.directSum(q1)
      
      if (q.det % 2 == 0 && q.hasComplementaryEmbeddings) {
        //println(s"r1=$r1, r2=$r2, r3=$r3, r4=$r4 ${q.hasComplementaryEmbeddings}, ${q.det % 2}, ${sfs.homology}")
        //println(q2)
        //println(q2.embeddingsAsMatrices(Some(q2.rank)))
        println(s"$sfs, ${q.det % 2}, ${sfs.homology}")
      }

      //val Vector(u, v) =  q.complementaryEmbeddings.head
      //println(Spin.muBar(u.transpose))
      //println(Spin.muBar(v.transpose))
    //q.embeddings(q.rank).foreach { println }
    //println(q.complementaryEmbeddings)
      //println(q)
        }
    sys.exit(0)      
     */
    SFSOverS2.generateSFSs(3, 20, 1)
      .filter(sfs => sfs.coeffs.forall(_.numerator % 2 == 0))
      .filter(sfs => sfs.homologyOrder > 0 && ! sfs.isNegativeDefinite && sfs.homologyIsDirectDouble)
      .map(_.reverseOrientation)
      .filter(sfs => ! sfs.complementaryEmbsWithPartitions.isEmpty)
      .foreach(println)
      //.foreach { sfs => println(s"$sfs\n${sfs.homology}\n${sfs.complementaryEmbsWithPartitions}") }
    sys.exit(0)

    for (psqrt <- 2 to 10; q <- 1 until (psqrt**2) if gcd(psqrt, q) == 1) {
      val p = psqrt**2
      if (LensSpace.dInvariants(p, q).count(_ == 0)**2 >= p)
        println(s"$p,$q")
    }
    sys.exit(0)

    val sfsx = SFSOverS2(2, Vector(r"3", r"5/3", r"15", r"15/14")).reverseOrientation
    println(sfsx.toTree.complementaryEmbeddings(0)._1.toMatrixTranspose)
    val emba = sfsx.toTree.complementaryEmbeddings(0)._2.toMatrixTranspose
    //val qx = emba * emba.transpose // pos def

    val greeneJabuka = Matrix(Vector(
      Vector(1, -1, 0, 0, 0),
      Vector(0,  1,-1, 0, 0),
      Vector(0,  0, 1,-1, 0),
      Vector(0,  0, 0, 1,-1),
      Vector(1,  1, 2, 2, 2)))
    val qx = greeneJabuka * greeneJabuka.transpose

    val qa1019 = IntersectionForm(Vector(Vector(-4, 1, 1, 1, 0, 0), Vector(1, -4, 1, 0, 0, 1), Vector(1, 1, -3, 0, 0, 0), Vector(1, 0, 0, -3, 1, 1), Vector(0, 0, 0, 1, -3, 1), Vector(0, 1, 0, 1, 1, -3)))
    val qa1202 = IntersectionForm(Vector(Vector(-5, 2, 1, 0, 0, 0), Vector(2, -5, 0, 1, 0, 0), Vector(1, 0, -2, 0, 1, 0), Vector(0, 1, 0, -2, 1, 0), Vector(0, 0, 1, 1, -3, 1), Vector(0, 0, 0, 0, 1, -2)))
    val embb = qa1202.complementaryEmbeddings(0)._1
    //println("Check: " + emba * emba.transpose)
    //println("Satisfies d-inv: " + satisfiesDInvariantRestraint(emba, qx))
    println("Satisfies d-inv: " + satisfiesDInvariantRestraint(embb))
    println(SFSOverS2(1, Vector(r"3", r"5", r"13/6")).reverseOrientation.toTree.latticeEmbeddings())
    sys.exit(0)
    /*
    val m = 11
    for (q1 <- 2 until m if gcd(m, q1) == 1;
      q2 <- 2 until m if q2 <= q1 && gcd(m, q2) == 1;
      q3 <- 2 until m if q3 <= q2 && gcd(m, q3) == 1) {
      val sfs = SFSOverS2(1, Vector[Rational](Rational(m,q1), Rational(m,q2), Rational(m,q3)))
      if (sfs.homologyOrder != 0 &&
        sfs.homologyIsDirectDouble &&
        !sfs.negDef.toTree.muBarCompatComplementaryEmbs.isEmpty) {
        println(sfs)
        sfs.negDef.toTree.muBarCompatComplementaryEmbs.foreach { println }
      }
     }*/

    /*
    val sfs = SFSOverS2(3, Vector(r"2", r"2", r"2"))
    println(sfs.homology)
    val dinv = sfs.dInvariants.raw
    println(dinv.length)
    println(dinv.flatMap(d => dinv.map(_ - d)).count(_ == 0))
     */

    //sys.exit(0)

    val sfs: SFSOverS2 = SFSOverS2(-3, Vector[Rational](r"-3", r"-3", r"-3/2"))
    
    
    println(sfs.homologyMatrix)
    println(s"homology: ${sfs.homology}")
    val qh = sfs.toTree.toIntersectionForm
    println(s"same rank emb: ${qh.embeddingsAsMatrices(Some(qh.rank))}")
    /*
    println(s"Intersection form: $qh")
    println(qh.complementaryEmbeddings(0))
    val emb2 = qh.complementaryEmbeddings(0)._2
    val Q = qh.toMatrix
    val (diag, le, ri) = qh.toMatrix.extendedSmithForm
    println(s"diag: $diag")
    println(le * emb2 * ri)
    println(le * ri)
     */
    sys.exit(0)
    val qq = sfs.toPlanarGraph.dualGraph.toIntersectionForm.directSum(sfs.toTree.toIntersectionForm)
    //println(s"qq: $qq")
    //println("comp embs:")
    //qq.complementaryEmbeddings.foreach { println }
    //qq.embeddingsAsMatrices(Some(qq.rank)).foreach { println }
    //sys.exit(0)
    //println(s"has comp embs: ${sfs.toPlanarGraph.dualGraph.toIntersectionForm.directSum(sfs.negDef.toTree.toIntersectionForm).hasComplementaryEmbeddings}")
    println(s"qqhom: ${qq.toMatrix.invariantFactors}")
    //println(sfs.toPlanarGraph.dualGraph)
    sys.exit(0)

    val mat = Matrix(Vector(
      Vector(0,0,2,4,1,1,1),
      Vector(0,-1,0,-1,2,0,0),
      Vector(-1,1,0,-1,0,2,0),
      Vector(1,0,0,-1,0,0,2)))
    println(mat.invariantFactors)
    val mat2 = Matrix(Vector(
      Vector(-2,0,0,0,4,1,1,1),
      Vector(0,-1,0,1,-1,2,0,0),
      Vector(0,1,-1,0,-1,0,2,0),
      Vector(0,0,1,-1,-1,0,0,2)))
    println(mat2.invariantFactors)

    val mat3 = Matrix(Vector(
      Vector(4,1,1,1,1),
      Vector(-1,2,0,0,0),
      Vector(-1,0,2,0,0),
      Vector(-1,0,0,2,0),
      Vector(-1,0,0,0,2)))
    println(mat3.invariantFactors)

    val mat4 = Matrix(Vector(
      Vector(-2,0,0,0,0,4,1,1,1,1),
      Vector(0,-1,0,0,1,-1,2,0,0,0),
      Vector(0,1,-1,0,0,-1,0,2,0,0),
      Vector(0,0,1,-1,0,-1,0,0,2,0),
      Vector(0,0,0,1,-1,-1,0,0,0,2)))
    println(mat4.invariantFactors)

    val mat5 = Matrix(Vector(
      Vector(1,2,0,0),
      Vector(1,0,2,0),
      Vector(1,0,0,2)))
    println(mat5.invariantFactors)
    //sys.exit(0)
    /*
    for (a1 <- 2 to 20;
      b1 <- 1 until a1 if gcd(a1, b1) == 1;
      a2 <- 2 to 20;
      b2 <- 1 until a2 if gcd(a2, b2) == 1 && a1*b2 >= a2*b1;
      a3 <- 2 to 20;
      b3 <- 1 until a3 if gcd(a3, b3) == 1 && a2*b3 >= a3*b2;
      a4 <- 2 to 20;
      b4 <- 1 until a4 if gcd(a4, b4) == 1 && a3*b4 >= a4*b3
    ) {
      val r1 = Rational(-a1, b1)
      val r2 = Rational(-a2, b2)
      val r3 = Rational(-a3, b3)
      val r4 = Rational(-a4, b4)
      val sfs: SFSOverS2 = SFSOverS2(-1, Vector(r1, r2, r3, r4))
      if (sfs.homologyOrder == 1 && ! sfs.toTree.muBarCompatComplementaryEmbs.isEmpty) {
        println(sfs)
      }
    }*/
    //sys.exit(0)
    //println(q5.toMatrix.smithNormalForm())
    //val c = 3
    /*
    val sfs1: SFSOverS2 = SFSOverS2(3, Vector(r"2", r"-2", r"2", r"3"))
    val sfs2 = SFSOverS2(-3, Vector(r"-3", r"-2", r"2", r"-2"))
    println(s"hom: ${sfs1.homology}")
    //val q1 = sfs1.toPlanarGraph.dualGraph.toIntersectionForm
    //val q2 = sfs2.toPlanarGraph.dualGraph.toIntersectionForm
    val q3 = sfs1.toTree.toIntersectionForm
    val q4 = sfs2.toTree.toIntersectionForm
    val q = q3.directSum(q4)//.directSum(q3)
    println(s"int form: ${q}")
    //println(s"same rnk emb: ${q.embeddingsAsMatrices(Some(q.rank))}")

    //val q = q1.directSum(q2).directSum(q4)
    //println(q1.det)
    println(q3.det)
    println(s"has comp emb: ${q.hasComplementaryEmbeddings}")
    println(q)
    //q.complementaryEmbeddings.foreach { println }

    val mat6 = Matrix(Vector(
      Vector(0, 0, 0, 0,  -3,0,0,0,1,0,0,0,0,0),
      Vector(1, 0, 0, 1,  0,-3,0,0,1,0,0,0,0,0),
      Vector(0, 0, 0, 0,  0,0,-2,1,0,0,0,0,0,0),
      Vector(0, 0, 0, 1,  0,0,1,-2,1,0,0,0,0,0),
      Vector(0, 0, 1,-1,  1,1,0,1,-3,0,0,0,0,0),
      Vector(0, 0, 0, 0,  0,0,0,0,0,-3,0,0,0,1),
      Vector(0, 1, 1, 0,  0,0,0,0,0,0,-3,0,0,1),
      Vector(0, 0, 0, 0,  0,0,0,0,0,0,0,-2,1,0),
      Vector(0, 1, 0, 0,  0,0,0,0,0,0,0,1,-2,1),
      Vector(1,-1, 0, 0,  0,0,0,0,0,1,1,0,1,-3)))
    

    val mat7 = Matrix(Vector(
      Vector(0, 0, 0, 0, 3,0,0,-1,0,0,0,0),
      Vector(0, 0, 1, 0, 0,-3,0,-1,0,0,0,0),
      Vector(0, 0, 1, 1, 0,0,3,-1,0,0,0,0),
      Vector(1, 0, 0, 0, -1,-1,-1,2,0,0,0,0),
      Vector(1, 1, 0, 0, 0,0,0,0,3,0,0,-1),
     Vector( 0, 1, 0, 0, 0,0,0,0,0,-3,0,-1),
      Vector(0, 0, 0, 0, 0,0,0,0,0,0,3,-1),
      Vector(0, 0, 0, 1, 0,0,0,0,-1,-1,-1,-2)))
    println(s"invariant factors7: ${mat7.invariantFactors}")

    val mat8 = Matrix(Vector(
      Vector( 0, 0, 0, 0, 0, 0,  2,0,0,0,1,0,0,0,0,0),
      Vector( 0, 1, 0, 1, 0, 0,  0,2,0,0,1,0,0,0,0,0),
      Vector( 0, 0, 1, 0, 1, 0,  0,0,2,0,1,0,0,0,0,0),
      Vector( 1, 0, 0, 0, 0, 1,  0,0,0,3,1,0,0,0,0,0),
      Vector( 0, 0, 0, 0, 0, 0,  1,1,1,1,3,0,0,0,0,0),
      Vector(-1, 0, 0, 0, 0, 1,  0,0,0,0,0,-3,0,0,0,1),
      Vector( 0, 0, 0, 0, 1, 0,  0,0,0,0,0,0,-2,0,0,1),
      Vector( 0, 0,-1, 1, 0, 0,  0,0,0,0,0,0,0,-2,0,1),
      Vector( 0,-1, 0, 0, 0, 0,  0,0,0,0,0,0,0,0,-2,1),
      Vector( 0, 0, 0, 0, 0, 0,  0,0,0,0,0,1,1,1,1,-3)))
    //println(s"invariant factors: ${mat8.invariantFactors}")

    //sys.exit(0)
     */
    
    val sfss = 
    for (a1 <- 2 to 4;
      b1 <- 1 until a1 if gcd(a1, b1) == 1;
      a2 <- 2 to 4;
      b2 <- 1 until a2 if gcd(a2, b2) == 1 && a1*b2 >= a2*b1;
      a3 <- 2 to 4;
      b3 <- 1 until a3 if gcd(a3, b3) == 1 && a2*b3 >= a3*b2
    ) yield {
      val r1 = Rational(-a1, b1)
      val r2 = Rational(-a2, b2)
      val r3 = Rational(-a3, b3)
      val sfs: SFSOverS2 = SFSOverS2(-3, Vector(r1, r2, r3))
      sfs
    }

    
    for (sfs <- sfss) {
      val q2 = sfs.toTree.toIntersectionForm
      //val q2 = sfs.toPlanarGraph.dualGraph.toIntersectionForm
      val q3 = q2//.directSum(q2)//.directSum(q2).directSum(q2)
      val q4 = q2.directSum(q2)//.directSum(q2).directSum(q2)
      val q = q2.directSum(q2)
      if (q.hasComplementaryEmbeddings) {
        println(sfs)
        println(q2)
        q.complementaryEmbeddings.foreach { println }
      } else {
        //println(s"no: $sfs")
      }

    }
     
    sys.exit(0)
    /*
    for (sfs1 <- sfss;
      sfs2 <- sfss) {
      val q1 = sfs2.toPlanarGraph.dualGraph.toIntersectionForm
      //val q1 = sfs2.toTree.toIntersectionForm
      val q2 = sfs1.toTree.toIntersectionForm
      val q3 = sfs1.toPlanarGraph.dualGraph.toIntersectionForm
      val q4 = sfs2.toTree.toIntersectionForm

      val q5 = q2.directSum(q2).directSum(q4).directSum(q4)
      
      if (/*sfs1.homology == sfs2.homology &&*/ q5.hasComplementaryEmbeddings) {
        //println(s"r1=$r1, r2=$r2, r3=$r3, r4=$r4 ${q.hasComplementaryEmbeddings}, ${q.det % 2}, ${sfs.homology}")
        
        println(s"$sfs1 # $sfs2, ${sfs.homology} POTENTIAL")
        if (q1.directSum(q3).hasComplementaryEmbeddings) {
          println(s"$sfs1 # $sfs2, ${sfs.homology} TRUE")
          //println(s"-Y1#Y1#-Y2 ${q3.directSum(q2).directSum(q1).hasComplementaryEmbeddings}")
        } else {
          println("nope")
        }


        //require(sfs1 == sfs2)
      }
    }*/

    //sys.exit(0)
    for (a1 <- 2 to 8;
      b1 <- 1 until a1 if gcd(a1, b1) == 1;
      a2 <- 2 to 8;
      b2 <- 1 until a2 if gcd(a2, b2) == 1 && a1*b2 >= a2*b1;
      a3 <- 2 to 8;
      b3 <- 1 until a3 if gcd(a3, b3) == 1 && a2*b3 >= a3*b2
      //;a4 <- 2 to 8;
      //b4 <- 1 until a4 if gcd(a4, b4) == 1 && a3*b4 >= a4*b3
      //;a5 <- 2 to 8;
      //b5 <- 1 until a5 if gcd(a5, b5) == 1 && a4*b5 >= a5*b4
    ) {
      
      val r1 = Rational(-a1, b1)
      val r2 = Rational(-a2, b2)
      val r3 = Rational(-a3, b3)
      //val r4 = Rational(-a4, b4)
      //val r5 = Rational(-a5, b5)
      //println(s"r1=$r1, r2=$r2, r3=$r3")
      val sfs: SFSOverS2 = SFSOverS2(-3, Vector(r1, r2, r3))
      //println(s"orig graph: ${sfs.toPlanarGraph}")
      //println(s"dual graph: ${sfs.toPlanarGraph.dualGraph}")
      val q1 = sfs.toPlanarGraph.dualGraph.toIntersectionForm
    //println(q1)
    //println(q)
    val q2 = sfs.toTree.toIntersectionForm
      val q = q2.directSum(q1)
      
      if (q.det % 2 == 0 && ! q2.embeddingsAsMatrices(Some(q2.rank)).isEmpty/*q.hasComplementaryEmbeddings*/) {
        //println(s"r1=$r1, r2=$r2, r3=$r3, r4=$r4 ${q.hasComplementaryEmbeddings}, ${q.det % 2}, ${sfs.homology}")
        println(q2)
        println(q2.embeddingsAsMatrices(Some(q2.rank)))
        println(s"$sfs, ${q.det % 2}, ${sfs.homology}")
      }

      //val Vector(u, v) =  q.complementaryEmbeddings.head
      //println(Spin.muBar(u.transpose))
      //println(Spin.muBar(v.transpose))
    //q.embeddings(q.rank).foreach { println }
    //println(q.complementaryEmbeddings)
      //println(q)
    }

    sys.exit(0)
     
    //TriangleGUI.run()
    //sys.exit(0)

    //{17/99, 3/10, 11/26}
    /*
    val knownEmbPts = EmbeddingConstant.gapFilling(100)
    EmbeddingConstant.gapFillingAlongArcs(knownEmbPts)
    sys.exit(0)
     */
    //val sfs = SFSOverS2(-1,Vector(r"-4", r"-4"-r"-1/100", r"-12/5"-r"-1/60"))
    
    //val sfs = SFSOverS2(-1,Vector((r"-73/13"+r"-1/300").limitTo(300), (r"-73/16"+r"-1/70").limitTo(200), (r"-113/34").limitTo(1000), (r"-1461/319"+r"-1/400").limitTo(500)))
    //val sfs = SFSOverS2(-1,Vector((r"-73/13"+r"-1/300").limitTo(300), (r"-1461/319"+r"-1/400").limitTo(300), (r"-113/34").limitTo(1000), (r"-1461/319"+r"-1/400").limitTo(300)))
    //println(MontesinosIntersectionForm.linearChain(r"-19/15"))
    //val s = 3
    //val sfs = SFSOverS2.brieskorn(Vector[SafeLong](4, 4*s-1, 8*(4*s-1)+4*s+1)).negDef
    //val sfs = SFSOverS2.brieskorn(Vector[SafeLong](4, 4*s+1, 8*(4*s+1)+4*s-1)).negDef
    //val sfs = SFSOverS2.brieskorn(Vector[SafeLong](5, 7, 76)).negDef
    //val up = 26
    /*
    for (p <- 2 to up;
      q <- 2 to up if p < q && gcd(p,q) == 1;
      r <- 2 to up if q < r && gcd(q,r) == 1 && gcd(p,r) == 1 /*&& (p >= 25 || q >= 25 || r >= 25)*/ /*&& p == 2 && q == 3 && r == 25*/) {
      val sfs = SFSOverS2.brieskorn(Vector[SafeLong](p, q, r)).negDef
      val embs = sfs.toTree.toIntersectionForm.embeddingsAsMatrices()
      if (sfs.knownToBoundAcyclic == "Unknown" && !embs.isEmpty) {
        val a = embs(0)
        if (Spin.muBar(a.transpose) == Vector(0)) {
          if (embs.exists({ emb =>
            val n = emb.nCols
              (0 until n).exists(i =>
                (0 until emb.nRows).count(j => emb(j)(i).abs != 0) == 1)
          })) {
            println(sfs)
            println(sfs.toTree)
            sfs.toTree.latticeEmbeddings().foreach { println }
            println(embs(0))
          }
        }
      }
     }*/

    //val sfs = SFSOverS2.brieskorn(Vector[SafeLong](3,5,8)).nonDef//.reverseOrientation
    //println(sfs)
    //println(sfs.toTree.toLabelledTree)
    //val sfs = SFSOverS2(2, Vector(r"2", r"3/2", r"6/5"))
    //sfs.prettyPotentialHandles()
    //sfs.prettyGenPotentialHandles(comps = 3, framing = -1)
    //println(sfs.toTree.toLabelledTree)
    //println((-10 until 10).map(i => (i, sfs.genPotentialHandles(framing=i, links=1))))
    //println(sfs.genPotentialHandles(framing = 4, links = 1))
    //val sfs = SFSOverS2(1, Vector(r"2", r"3", r"33/5")).negDef
    //println(sfs.toTree.latticeEmbeddings())
    //println(sfs.toTree)
    //println(sfs.buildAddedHandleQ(Vector(4, 5, 7), Vector(-1, 1, -1), 1))
    //val sfs = SFSOverS2(1, Vector(r"25", r"25", r"14/5"))
    //println(sfs.toTree.latticeEmbeddings())
    //val embs = sfs.toTree.toIntersectionForm.embeddingsAsMatrices()
    //println(embs(0))
    /*
    val up = 25
    var filenames = Vector[String]()
    for (p <- 2 to up;
      q <- 2 to up if p < q && gcd(p,q) == 1;
      r <- 2 to up if q < r && gcd(q,r) == 1 && gcd(p,r) == 1 /*&& (p >= 25 || q >= 25 || r >= 25)*/) {
      val sfs = SFSOverS2.brieskorn(Vector[SafeLong](p, q, r)).negDef
      val embs = sfs.toTree.toIntersectionForm.embeddingsAsMatrices()
      if (sfs.knownToBoundAcyclic == "Unknown" && !embs.isEmpty) {
        val a = embs(0)
        if (Spin.muBar(a.transpose) == Vector(0)) {
          println((p, q, r))
          val sfsToTest = sfs.nonDef//.negDef.reverseOrientation
          println(sfsToTest)
          println(sfsToTest.toTree)
          val handles = sfsToTest.potentialHandles(framing = 1, goalDet = 1)
          for (handle <- handles) {
            val recognizer = s"%bri_${p}_${q}_${r}${handle}\r\n" + sfsToTest.toRecogniserWithHandle(handle, 1)
            //println(recognizer)
            saveToFile(recognizer, s"C:/Users/Ahmad/Dropbox/code/Recognizer(2015_04_18)/bri_${p}_${q}_${r}${handle}.txt")
            filenames = filenames :+ s"bri_${p}_${q}_${r}${handle}.txt"
          }

          /*
          if (!handles.isEmpty && !handles.flatMap(handle => sfsToTest.identifyPotentialS3(handle, 1)).isEmpty) {
            println(sfsToTest)
            println(sfsToTest.toTree.toLabelledTree)
            println(handles)
            for (handle <- handles;
              knot <- sfsToTest.identifyPotentialS3(handle, 1)) {
              println(s"handle: $handle, knot: $knot")
              val recognizer = s"%bri_${p}_${q}_${r}${handle}_${knot}\r\n" + sfsToTest.toRecogniserWithHandle(handle, 1, Some(knot), Some("1/0"))
              //println(recognizer)
              saveToFile(recognizer, s"C:/Users/Ahmad/Dropbox/code/Recognizer(2015_04_18)/bri_${p}_${q}_${r}${handle}_${knot}.txt")
              filenames = filenames :+ s"bri_${p}_${q}_${r}${handle}_${knot}.txt"
            }
          }*/
        }
      }
    }
    saveToFile(filenames.mkString("\r\n"), s"C:/Users/Ahmad/Dropbox/code/Recognizer(2015_04_18)/filenames.txt")
     */
     
    /*
    val sfs = SFSOverS2.brieskorn(Vector[SafeLong](3,7,11)).negDef
    //println(SFSOverS2.brieskorn(Vector[SafeLong](3,19,20)).knownToBoundAcyclic)
    
    //val sfs = SFSOverS2(1,Vector(r"-10", r"3", r"13/10"))
    //println(sfs)
    println("nondef: \n" + sfs.toTree.toLabelledTree)
    val handles = sfs.potentialHandles(framing = 1)
    println(s"handles = $handles")
    println("potential knot: " + sfs.identifyPotentialS3(handles(0), 1))
    println("lab to index: " + sfs.labelToIndex(0))
    val recognizer = sfs.toRecogniserWithHandle(handles(0), 1, Some(0), Some("1/0"))
    println(recognizer)
     */
    //saveToFile(recognizer, "C:/Users/Ahmad/Dropbox/code/Recognizer(2015_04_18)/test.txt")
    //println(sfs.toTree)
    //sfs.toTree.latticeEmbeddings().foreach { println }
     
    //val a = sfs.toTree.toIntersectionForm.embeddingsAsMatrices()(0)
    //println(Spin.muBar(a.transpose))
    //val sfs = SFSOverS2.brieskorn(Vector[SafeLong](2,7,19)).negDef
    //println(sfs.knownToBoundAcyclic)
    //sfs.toTree.latticeEmbeddings().foreach { println }
    //println(sfs.toTree.toIntersectionForm.embeddingsAsMatrices().filter(_.isSurjective))
    //sys.exit(0)
     

    /*
    val n = 9
    val intpts =
      for (a <- 2 to n; b <- a to n; c <- b to n;
           d <- c to n; e <- d to n if 1/a.toRational+1/b.toRational+1/c.toRational+1/d.toRational+1/e.toRational == 1) yield Vector(a, b, c, d, e)
    println(intpts.length)
    println(intpts)
    //val withperms = intpts.toVector.flatMap(_.permutations.toVector.distinct).map(_.map(1/_.toRational))
    val withperms = intpts.toVector.map(_.map(1/_.toRational).sortBy(x => -x))
    println(s"perms: ${withperms.length}")
    println(EmbeddingConstant.lowerboundDouble(
      /*Vector(Vector(3,3,3), Vector(2,3,6), Vector(2,4,4)*/
      withperms.take(50), 0.49))
     */

    //println(FieldMatrix[Double](Vector(Vector(0.0000001,4.,1.),Vector(1.,2.,1.))).rowReduced())

    
    /*
    import scala.io.Source
    val hasEmb = 
      Source.fromFile("3fib_has_emb_100.txt")
        .getLines()
        .map(line => line.split(",").toVector.map(Rational(_)))
        .toVector
     */
    /*
      .mkString
      .trim()
      .split(java.util.regex.Pattern.quote("},{"))
      .map(s => s.replace("{", "").replace("}", "").split(",").map(Rational(_)).toVector)
      .toVector // :+ Vector(r"20/17", r"20", r"20", r"20")
     */

    
    //val hasEmbPermed = hasEmb.flatMap(p => p.map(r => 1/r).permutations.toVector.distinct)//.reverse.flatMap(_.permutations.toVector.distinct)
      //println("Permed size: " + hasEmbPermed.length)
    //hasEmbPermed.sortBy(x => (x(0), x(1), x(2)))
    //  .reverse.take(10).foreach{println _}

    /*
    var used: Vector[Vector[Rational]] = hasEmbPermed.take(1)
    for (i <- 0 to 1000) {
      val notCovered = EmbeddingConstant.cubesMinimum(used)
      hasEmbPermed.find(v => !used.contains(v) && (0 until 3).forall(i => notCovered(i) < v(i))) match {
        case Some(v) => {
          println(s"adding: $v")
          used = used :+ v
        }
        case None => {

        }
      }
      println(s"best: ${notCovered.qsum} $notCovered ${notCovered.qsum.toDouble}") 
     }*/

    //val test = Vector(Vector(r"1/3", r"1/3", r"1/3"), Vector(r"2/9", r"2/9", r"5/9"), Vector(r"4/27", r"4/27", r"19/27"), Vector(r"1/4", r"1/4", r"1/2"))
    //val test = Vector(Vector(r"1/3", r"1/3", r"1/3"))
    //println(EmbeddingConstant.cubesMinimum(test))
    //val notCovered = Vector(r"0", r"1/4", r"46/111")
    //println(hasEmbPermed.find(v => (0 until 3).forall(i => notCovered(i) < v(i))))
    //17/99, 3/10, 11/26

    /*
    var pts = EmbeddingConstant.gapFilling(18)
    val embC = EmbeddingConstant.cubesMinimum(pts)
    var found = true
    while (found) {
      pts.find(p => EmbeddingConstant.cubesMinimum(pts.filter(_ != p)) == embC) match {
        case Some(p) => pts = pts.filter(_ != p)
        case None => found = false
      }
    }
    println(pts)

    println(pts.exists(p => EmbeddingConstant.cubesMinimum(pts.filter(_ != p)) == embC))
     */
    //EmbeddingConstant.cubesMinimum(hasEmbPermed.take(1))
    //println(EmbeddingConstant.cubesMinimum(hasEmbPermed.take(900)))
    
    //println(EmbeddingConstant.lowerboundDouble(hasEmbPermed, 0.90))
    //println(s"""implies: ${EmbeddingConstant.impliesPointEmbeds(Vector(r"13/30", r"3/10", r"1/6"), hasEmbPermed)}""")
    //sys.exit(0)
    
    //println(s"Calls: ${EmbeddingConstant.calls}")
     
    //println(MontesinosIntersectionForm.linearChain(r"-80/77"))
    //79/39,79/39,79
    //35/17,63/31,45
    //19/15,76/15,76
    //80/77,40,80
    //80/77,48,60
    //-99/74, -88/21, -72
    //40/39,72,90
    //95/91,95/2,95/2
    //75/38,60/29,100
    //75/73,60,100
    /*
    println(LatticeEmbedding.symmetries(Vector(1,1,1,2,2,3)))
    println(MontesinosIntersectionForm.linearChain(r"-75/38"))
    println(MontesinosIntersectionForm.linearChain(r"-60/29"))
    println(MontesinosIntersectionForm.linearChain(r"-100"))
    println(SFSOverS2(-1, Vector(r"-40/39", r"-72", r"-90"))
      .toTree
      .toIntersectionForm
      .embeddings()
      //.embeddingsMaxDuration(300000)
     )
     
     sys.exit(0)
     */
    /*
    println(
      LatticeEmbedding.embeddings(
        IntersectionForm(Vector(Vector(-30, -1), Vector(-1, -30)))
      )
     )*/
    // 9/8,20,30,36

    //SFSOverS2(-1, Vector(r"-9/8", r"-20", r"-30", r"-36")).toTree.latticeEmbeddings().take(1).foreach { println }
    //LatticeEmbedding.paddedSignedVectorsOfNormAtMost(6, 3).foreach { println _ }
    //sys.exit(0)
     

    /*
    val mm = 8
    val (hasEmb, noEmb) = SFSOverS2.genSFSEmb(5, mm, boundary=true,
      pred = c => (c.map(r => 1/r).qsum <= 1 && c.forall(r => r.numerator <= mm)))
    println(hasEmb.length)
    println(hasEmb)
     
    
    println("Lowerbound: " +
      EmbeddingConstant.lowerbound(hasEmb.flatMap(_.permutations.toVector.distinct).map(_.map(r => 1/r)), r"1/2"))
    println(noEmb.length)
    println("Upperbound: " + (noEmb.map(_.map(r => 1/r).qsum) :+ r"1").min)
     */
    //{61/180, 73/180, 23/90}
    //println(SFSOverS2(-1, Vector(r"-180/61", r"-180/73", r"-90/23")).toTree)
    //println(SFSOverS2(-1, Vector(r"-180/61", r"-180/73", r"-90/23")).toTree.latticeEmbeddings())
    /*
    import scala.io.Source
    val skippedSFSs = 
    Source.fromFile("3fib_skipped_100_r2.txt").getLines()
      .map(line => SFSOverS2(-1, line.split(",").toVector.map(-Rational(_))))
      .toVector
    //println(skippedPts.take(10))
    val hasEmbWriter = new PrintWriter(new File("3fib_has_emb_100_r3.txt"))
    val noEmbWriter = new PrintWriter(new File("3fib_no_emb_100_r3.txt"))
    val skippedWriter = new PrintWriter(new File("3fib_skipped_100_r3.txt"))

    for (sfs <- skippedSFSs) {
      val (r1, r2, r3) = (-sfs.coeffs(0), -sfs.coeffs(1), -sfs.coeffs(2))
      //sfs.toTree.toIntersectionForm.embeddingsMaxDuration(3600000) match {
      Some(sfs.toTree.toIntersectionForm.embeddings()) match {
        case Some(embs) => {
          val hasEmb = ! embs.isEmpty
          println(s"$sfs has embeddings: $hasEmb")
          if (hasEmb) {
            hasEmbWriter.write(s"$r1,$r2,$r3\r\n")
            hasEmbWriter.flush()
          } else {
            noEmbWriter.write(s"$r1,$r2,$r3\r\n")
            noEmbWriter.flush()
          }
        }
        case _ => {
          println(s"SKIPPED: $sfs")
          skippedWriter.write(s"$r1,$r2,$r3\r\n")
          skippedWriter.flush()
        }
      }
    }
    hasEmbWriter.close()
    noEmbWriter.close()
    skippedWriter.close()
    sys.exit(0)
     */
    
    
    var hasLatticeEmb = Vector[(Rational, Rational, Rational)]()
    var noLatticeEmb = Vector[(Rational, Rational, Rational)]()

    
    val upper = 40
    val hasEmbWriter = new PrintWriter(new File("3fib_e2_has_emb.txt"))
    val noEmbWriter = new PrintWriter(new File("3fib_e2_no_emb.txt"))
    val skippedWriter = new PrintWriter(new File("3fib_e2_skipped.txt"))

    for (//t <- 2 to 10
       a1 <- 2 to upper; b1 <- 1 until a1 if gcd(a1,b1) == 1 //&& (a1 < 12 || Rational(b1, a1) < Rational(9,10) && Rational(b1, a1) > Rational(1,10))
      ;a2 <- 2 to upper; b2 <- 1 until a2 if gcd(a2,b2) == 1 && a1*b2 <= a2*b1
      //&& (a2 < 12 || Rational(b2, a2) < Rational(9,10) && Rational(b2, a2) > Rational(1,10))
       //;a3 <- 2 to upper; b3 <- 1 until a3 if gcd(a3,b3) == 1 && a2*b3 <= a3*b2 //&& Rational(b1,a1)+Rational(b2,a2)+Rational(b3,a3) <= 1 && Rational(b1,a1)+Rational(b2,a2)+Rational(b3,a3) >= r"92/100"
      //;a4 <- 2 to upper; b4 <- 1 until 2 if gcd(a4,b4) == 1 && a3*b4 <= a4*b3
      //;a5 <- 2 to upper; b5 <- 1 until 2 if gcd(a5,b5) == 1 && a4*b5 <= a5*b4
      //;a6 <- 2 to upper; b6 <- 1 until a6 if gcd(a6,b6) == 1 && a5*b6 <= a6*b5
      //;a7 <- 2 to upper; b7 <- 1 until a7 if gcd(a7,b7) == 1 && a6*b7 <= a7*b6
    ) {
      //val a2 = a1
      //val b2 = b1
      val r1 = Rational(a1, b1)
      val r2 = Rational(a2, b2)
      //val r3 = Rational(a3, b3)
      //val r4 = Rational(a4, b4)
      //val r5 = Rational(a5, b5)
      if (2 - 1/r1 - 1/r2  > 0) {
        //val r3 = 1/(1 - 1/r1 - 1/r2)
        //if (r3 <= r2 && r3.numerator <= 70 && ((a1 < 25 && a2 < 25 && r3.numerator < 25) || (r3 <= r"12/5" && r2 <= r"10/3" && r1 <= r"6"))
        //val r4 = 1/(1 - 1/r1 - 1/r2 - 1/r3)
        val r3 = 1/(2 - 1/r1 - 1/r2)
        //if (r4.numerator <= upper && r4 >= r3)
        if (r3.numerator <= upper && r3 >= r2)
        {
          //if (r3.numerator < 12 || (1/r3 < 0.9 && 1/r3 > 0.1)) {
          //val sfs = SFSOverS2(-1,Vector(-r1, -r2, -r3, -r4))
          val sfs = SFSOverS2(-2,Vector(-r1, -r2, -r3))
          sfs.toTree.toIntersectionForm.embeddingsMaxDuration(10000) match {
          //val time = System.currentTimeMillis()
          //Some(sfs.toTree.toIntersectionForm.embeddings()) match {
              case Some(embs) => {
                val hasEmb = ! embs.isEmpty
                println(s"$sfs has embeddings: $hasEmb")
                //assert(System.currentTimeMillis() - time < 30000)
                val perms = Vector((r1,r2,r3), (r1,r3,r2), (r2,r1,r3), (r2,r3,r1),
                  (r3,r1,r2), (r3,r2,r1))
                //val perms = Vector(Vector(r1,r2,r3), Vector(r1,r3,r2), Vector(r2,r1,r3), Vector(r2,r3,r1),Vector(r3,r1,r2), Vector(r3,r2,r1))
                //val perms = Vector(Vector(r1,r2))
                if (hasEmb) hasLatticeEmb = perms ++ hasLatticeEmb
                if (hasEmb) {
                  //hasEmbWriter.write(s"{$r1,$r2,$r3,$r4},")
                  hasEmbWriter.write(s"$r1,$r2,$r3\r\n")
                  hasEmbWriter.flush()
                } else {
                  //noEmbWriter.write(s"{$r1,$r2,$r3,$r4},")
                  noEmbWriter.write(s"$r1,$r2,$r3\r\n")
                  noEmbWriter.flush()
                  //println((1/r1 + 1/r2 + 1/r3).toDouble)
                  noLatticeEmb = perms ++ noLatticeEmb
                  //assert(false)
                }

              }
              case _ => {
                println(s"SKIPPED: $sfs")
                //skippedWriter.write(s"{$r1,$r2,$r3,$r4},")
                skippedWriter.write(s"$r1,$r2,$r3\r\n")
                skippedWriter.flush()
              }

            }
          //}
        }
      }
    }

    hasEmbWriter.close()
    noEmbWriter.close()
    skippedWriter.close()
     
    //println("hasEmbs: " + hasLatticeEmb)
    /*
    println("Minimum: " + cubesMinimum(hasLatticeEmb.map({case (x,y,z) => (1/x, 1/y, 1/z)}) ++
      Vector((r"1",r"1",r"0"), (r"0",r"1",r"1"), (r"1",r"0",r"1"), (r"1/20", r"1/20", r"9/10"),
        (r"1/22", r"1/22", r"10/11"), (r"1/24", r"1/24", r"11/12"), (r"2/11", r"4/13", r"8/19"), (r"4/13", r"2/11", r"8/19")
      )))
     */
    //println(EmbeddingConstant.cubesMinimum(hasLatticeEmb.map(pt => pt.map(r => 1/r))))
     
    //println(EmbeddingConstant.cubesMinimum(Vector(Vector(r"1/3", r"1/3", r"1/3"))))
    //println(cubesMinimum(Vector((r"1",r"1",r"0"), (r"0",r"1",r"1"), (r"1",r"0",r"1"), (r"1/3", r"1/3", r"1/3"))))

    
    val hasEmbMathematica = "{" +
    hasLatticeEmb.map(pt => (1/pt._1, 1/pt._2, 1/pt._3))
      .map(pt => projectTriangleToR2(pt))
      .mkString(", ")
      .replace("(", "{")
      .replace(")", "}") + "}"
    val noEmbMathematica = "{" +
    noLatticeEmb.map(pt => (1/pt._1, 1/pt._2, 1/pt._3))
      .map(pt => projectTriangleToR2(pt))
      .mkString(", ")
      .replace("(", "{")
      .replace(")", "}") + "}"
     

    //val writer = new PrintWriter(new File("embs5.txt"))
    //writer.write(s"Has lattice emb: \n$hasLatticeEmb\n\n")
    //writer.write(s"Doesn't have lattice emb: \n$noLatticeEmb")
    //writer.close()

    
    val writer2 = new PrintWriter(new File("emb6.txt"))
    writer2.write(s"""Export["C:/Users/Ahmad/Dropbox/code/HF_Homology/emb17.pdf", ListPlot[{$hasEmbMathematica, $noEmbMathematica}, PlotMarkers -> {{Green, 3}, {Red, 3}}, ImageSize -> 1200]]""")
    writer2.close()
     


    /*
    val lower = -100
    val upper = 100
    for (a1 <- lower to upper; a2 <- lower to upper; a3 <- lower to upper if a1*a1-a2*a2-a3*a3 == -2;
      b1 <- lower to upper; b2 <- lower to upper; b3 <- lower to upper if b1*b1-b2*b2-b3*b3 == -3
      //c1 <- lower to upper; c2 <- lower to upper; c3 <- lower to upper if c1*c1-c2*c2-c3*c3 == 5
        ) {
      //if (a1*b1-a2*b2-a3*b3 == -1 && a1*c1-a2*c2-a3*c3 == 0 && b1*c1-b2*c2-b3*c3 == 0)
      if (a1*b1-a2*b2-a3*b3 == 1)
        println(s"a1=$a1, a2=$a2, a3=$a3, b1=$b1, b2=$b2, b3=$b3")//, c1=$c1, c2=$c2, c3=$c3")
    }*/


    //println(LensSpace.dInvariants(27, 1))
    /*
    import Tree.{rationalChain => rat, tree => t}
    //val tree = t(-2, rat(r"-2"), rat(r"-7/3"), t(-2, rat(r"-3"), rat(r"-3/2")))
    //val tree = t(-2, rat(r"-2"), rat(r"-3/2"), t(-2, t(-2, t(-2, t(-2, t(-2), t(-2))))))
    val tree = t(-4, rat(r"-5/2"), rat(r"-5/2"), t(-1, t(-2), t(-2)))
    import Tree.{rationalChain => rat, tree => t}
    val tree = t(-2, rat(r"-2"), rat(r"-3"), t(-2, rat(r"-2"), rat(r"-11/7")))
    println(tree)
    println(tree.isNegativeDefinite)
    println(tree.complementaryEmbeddings)
    println(tree.latticeEmbeddings(Some(tree.numVertices)))
    println(tree.toIntersectionForm.toMatrix.invariantFactors)
    println(tree.toIntersectionForm)
     */
     
    //val q = IntersectionForm(Vector(Vector(2,-2),Vector(-2,4)))
    //println(q.toMatrix.invariantFactors)
    //println(q.complementaryEmbeddings)
    //println(tree.complementaryEmbeddings)
    //println(tree.muBarCompatComplementaryEmbs)
    //println(tree.latticeEmbeddings(Some(tree.numVertices)))
    
    /*
    val q = IntersectionForm(
     Vector(Vector(-2, 1, 0, 0, 0, 0), Vector(1, -5, 2, 0, 0, 0), Vector(0, 2, -2, 1, 1, 0), Vector(0, 0, 1, -2, 0, 0), Vector(0, 0, 1, 0, -2, 1), Vector(0, 0, 0, 0, 1, -3)))
      //Vector(Vector(-5, 3, 0, 0, 0, 0), Vector(3, -3, 1, 0, 1, 0), Vector(0, 1, -3, 1, 0, 0), Vector(0, 0, 1, -2, 0, 0), Vector(0, 1, 0, 0, -2, 1), Vector(0, 0, 0, 0, 1, -3)))
    println(q.complementaryEmbeddings)*/
    //println(SFSOverS2.brieskorn(Vector(2, 7, 47)).negDef)
    /*
    val m = SFSOverS2(2, Vector(r"2", r"3", r"6/5", r"6"))
    val tr = m.negDef.toTree
    val q = tr.toIntersectionForm.toMatrix
    val rank = tr.numVertices
    val mat = q.adjoin(Matrix.id(rank)*2)
    println(q.adjoin(Matrix.id(rank)*2))
    println(mat.invariantFactors)
    println(tr.complementaryEmbeddings)
     */

    //println(Tree.chainToRat(Vector(2,2,2)))

    //println(Tree.rationalChain(r"19/15"))
    /*
    val x = 3
    val m = SFSOverS2(0, Vector(Rational(-2*x+3, x-1),
      Tree.chainToRat(Vector(x-1,-4)),
      Tree.chainToRat(Vector(2,-1,-2,-2,-2))))
     */
    /*
    import Tree.{tree => t, _}
    val px = t(-1, linearTree(2,-4), linearTree(-2,-2,-2,-2,-2), linearTree(-2,-2))
    println(px)
    println(px.toIntersectionForm)
    val q = px.toIntersectionForm.toMatrix
    val addit = Matrix(Vector(
      Vector(0, 1, 0, 0, 0, 1, 0, 0, 0, 0),
      Vector(0, 0, 1, 0, 0, 0, 0, -1, 0, 0),
      Vector(0, 0, 0, 0, 0, 0, 1, 0, -1, 0)
    )).transpose
     println(q.adjoin(addit).invariantFactors)*/
    /*
    println(Tree.chainToRat(Vector(-2,-2,-3,3)))
    println(Tree.chainToRat(Vector(2,3,2,2)))
    val x = -5
    //val m = SFSOverS2(0, Vector(Rational(-2*x+3, x-1),
    //  x-1 - Rational(x*x-2, x-1),
    //  2 - Rational(x-1, x*x -2)))
    val m = SFSOverS2(-2, Vector(r"-3/2", r"-24/17", r"-4/3"))
    println(m)
    println(m.homology)
     */
    //println(m.homologyIsDirectDouble)
    //val m = SFSOverS2(1, Vector(r"7/2", r"7/2", r"7/2"))
    //println(m.negDef.toTree.complementaryEmbeddings)
    //println(LensSpace.dInvariants(6,1))
    /*
    val m = Matrix(Vector(
      Vector(1,0,0,0),
      Vector(-1,1,0,0),
      Vector(-1,-1,1,0),
      Vector(0,0,-1,1),
      Vector(-1,-1,-2,-2)))
    println(m)

     println(m.invariantFactors)
    println(m.smithNormalForm())*/
    /*
    val upper = 30;
    for (a <- 2 to upper;
      b <- 2 to a;
      c <- 2 to b;
      d <- 2 to c) {
      if (Rational(1,a)+Rational(1,b)+Rational(1,c)+Rational(1,d) == 1)
        println(s"$a, $b, $c, $d")
    }*/

    /*
    val m = Matrix(Vector(
      Vector(-1,-1,-1,1,1,1),
      Vector(-1,1,0,-1,1,0),
      Vector(0,-1,1,0,-1,1)))
    println(m.invariantFactors)
     */
    /*
    val m = Matrix(Vector(
      Vector(0,1,1,1,1,0,0,0),
      Vector(1,-10,0,0,0,0,0,1),
      Vector(1,0,10,0,0,0,0,1),
      Vector(1,0,0,-2,0,0,1,0),
      Vector(1,0,0,0,2,1,1,0),
      Vector(0,0,0,0,1,3,0,0)))
    println(m.invariantFactors)
     */

    if (false) {
      //val M = SFSOverS2(0,Vector(r"-6", r"2", r"-3", r"6"))
      //val M = SFSOverS2(2,Vector(r"10/9", r"2/1", r"5/3", r"10/1"))
      //val M = SFSOverS2(0, Vector(r"-5/2", r"5/2", r"-5/2", r"3"))
      //val M = SFSOverS2(2,Vector(r"15/11", r"5/2", r"3/2", r"15/4"))
      //val M = SFSOverS2(2, Vector(r"10/7", r"2", r"5/3", r"10/3"))
      //val M = SFSOverS2(-3, Vector(r"-2", r"-2", r"-2", r"-2", r"-4/3"))
      //val M = SFSOverS2(-2, Vector(r"-15", r"-15/14", r"-3", r"-5/3"))
      //val M = SFSOverS2(1, Vector(r"7/2", r"7/2", r"7/2"))
      //val M = SFSOverS2(2, Vector(r"2", r"3", r"6", r"6/5"))
      //[(3, 2), (5, -2), (19, -5)]
      val M = SFSOverS2(4, Vector(r"2", r"2", r"2", r"5/3", r"5/2", r"5/3", r"5/2", r"5/3"))
      //val M = SFSOverS2.brieskorn(Vector(7, 8, 17))
      //val M = SFSOverS2(1, Vector(r"4", r"4", r"12/5"))
      //val M = SFSOverS2(0, Vector(r"2", r"-3", r"-25/4"))
      //val M = SFSOverS2(0, Vector(r"3/2", r"-4", r"-5/2"))
      //val M = SFSOverS2(2, Vector(r"6", r"5/4", r"30/29", r"30"))
      //val M = SFSOverS2(3, Vector(r"2", r"5/2", r"10/9", r"10", r"10/7", r"10/3"))
      //val M = SFSOverS2(5, Vector(r"2", r"3", r"6", r"6/5", r"3", r"3/2", r"6", r"6/5", r"2", r"2"))
      //val M = SFSOverS2(-2, Vector(r"-3/2", r"-3/2", r"-6/5"))
      //val M = SFSOverS2(3, Vector(r"6", r"2", r"3", r"6", r"6/5", r"6/5"))
      //val M = SFSOverS2(3, Vector(r"5/4", r"5", r"5/4", r"4", r"4/3", r"4"))
      //SFSOverS2(1,Vector(5/3, 5, 5/2)) h1: Vector(((5,1),2)), true
      println(M.negDef)
      println(M.homologyPrimeDecomposition)
      // Vector((-1,2), (10,7), (3,1), (10,7), (10,3))
       // Vector((-1,2), (10,9), (2,1), (5,3), (10,1))
      val tree = M.negDef.toTree
    //println(SFSOverS2(-2,Vector(r"-5/3",r"-10/7",r"-5/4")).negDef)
    //println(SFSOverS2(1,Vector(r"18/7", r"18/5", r"18/5")).negDef)
    //println("Q=" + tree.toIntersectionForm.toMatrix.mat)
    //tree.latticeEmbeddings(Some(tree.numVertices)).foreach { println _ }
    //  tree.toIntersectionForm.embImageHomology.foreach { println _ }
    //println("Complementary embeddings: " + tree.complementaryEmbeddings)
      //println("mu-bar complementary embeddings: " + tree.muBarCompatComplementaryEmbs)
      //println("Comp embeddings:\n" + tree.toIntersectionForm.complementaryEmbeddings)
      println("has comp emb: " + tree.toIntersectionForm.hasComplementaryEmbeddings)
    println("Q=" + tree.toIntersectionForm.toMatrix)
    //tree.latticeEmbeddings(Some(tree.numVertices)).foreach { emb => println(emb.toMatrixTranspose.mat) }
    println(M.negDef)
    println(M.homologyOrder)
    println(M.homologyPrimeDecomposition)
    println(M.homologyIsDirectDouble)
    //println(M.dInvariants.raw.count(_ == 0))

      //println(M.dInvariants)
    }

    /*
    val q = IntersectionForm(Vector(
      Vector(-3,1,1,0,0,0),
      Vector(1,-3,1,1,0,0),
      Vector(1,1,-3,0,1,0),
      Vector(0,1,0,-4,1,1),
      Vector(0,0,1,1,-4,1),
      Vector(0,0,0,1,1,-3)))
    q.embImageHomology.foreach { println _ }
     */

    if (false) {
    val upper = 7
    val e0 = 2
    var sfsWhichPass = Vector[String]()
    for (//t <- 2 to 10
        a1 <- 2 to upper; b1 <- 1 until a1 if gcd(a1,b1) == 1
       ;a2 <- 2 to upper; b2 <- 1 until a2 if gcd(a2,b2) == 1 && a1*b2 <= a2*b1
       ;a3 <- 2 to upper; b3 <- 1 until a3 if gcd(a3,b3) == 1 && a2*b3 <= a3*b2
      ;a4 <- 2 to upper; b4 <- 1 until a4 if gcd(a4,b4) == 1 && a3*b4 <= a4*b3
      //;a5 <- 2 to upper; b5 <- 1 until a5 if gcd(a5,b5) == 1 && a4*b5 <= a5*b4
      //;a6 <- 2 to upper; b6 <- 1 until a6 if gcd(a6,b6) == 1 && a5*b6 <= a6*b5
      //;a7 <- 2 to upper; b7 <- 1 until a7 if gcd(a7,b7) == 1 && a6*b7 <= a7*b6
    ) {
      //val sfs = SFSOverS2(e0,Vector(Rational(a1,b1),Rational(a2,b2),Rational(a3,b3),Rational(a4,b4),Rational(a5,b5),Rational(a6,b6),Rational(a7,b7)))
      //val sfs = SFSOverS2(e0,Vector(Rational(a1,b1),Rational(a2,b2),Rational(a3,b3),Rational(a4,b4),Rational(a5,b5)))
      //val sfs = SFSOverS2(e0,Vector(Rational(a1,b1),Rational(a2,b2),Rational(a3,b3),Rational(a4,b4),Rational(a5,b5),Rational(a6,b6)))
      val sfs = SFSOverS2(e0,Vector(Rational(a1,b1),Rational(a3,b3),Rational(a2,b2),Rational(a4,b4)))
      //val sfs = SFSOverS2(e0,Vector(Rational(a1,b1),Rational(a3,b3),Rational(a2,b2)))
      //val sfs = SFSOverS2(e0-3,Vector(Rational(a1,b1-a1),Rational(a1,b1-a1),Rational(a2,b2-a2)))
      //  val a1 = 3*t+1
      //  val b1 = t
      //val sfs = SFSOverS2(e0,Vector(Rational(a1,b1),Rational(a1,b1),Rational(a2,b2)))
      val s = sqrt(sfs.homologyOrder).round.toSafeLong

      if (s*s == sfs.homologyOrder
        && sfs.homologyOrder > 1
        //&& sfs.homologyOrder % 2 == 0
        //&& sfs.homologyOrder < 300
        && !sfs.isNegativeDefinite
        //&& sfs.isQA
        && sfs.homologyIsDirectDouble
        //&& sfs.isLSpace
        && sfs.dInvariants.raw.count(_ == 0) >= 2*s - 1
        //&& Rational(b1,a1)+Rational(b2,a2) < 1 && Rational(b3,a3)+Rational(b4,a4)<1
        //&& Rational(b5,a5)+Rational(b6,a6)<=1
      ) {
        //println(s"${sfs} h1: ${sfs.homologyPrimeDecomposition}, ${sfs.homologyIsDirectDouble}")
        val tree = sfs.negDef.toTree
        //val embeddings = tree.latticeEmbeddings(Some(tree.numVertices))
        //if (embeddings.length > 0) 
        //  println(s"${sfs} h1: ${sfs.homologyPrimeDecomposition}, ${sfs.homologyIsDirectDouble}")
        
        //if (tree.toIntersectionForm.hasComplementaryEmbeddings) {
        if (tree.muBarCompatComplementaryEmbs.length > 0) {
          val nDef = sfs.negDef
          //println(sfs)
          /*
          val embsWithPartitions = sfs.complementaryEmbsWithPartitions
          
          val embsWithLargeComplementary = embsWithPartitions.filter({
            case ((p1, emb1), (p2, emb2)) =>
              Vector(p1, p2).exists(p =>
                p.exists(legs =>
                  legs.length > 2
                  && legs.map(i => -1/nDef.coeffs(i)).qsum == 1)
              )
          })*/

          //if (embsWithLargeComplementary.length > 0) {
          println(s"${sfs} h1: ${sfs.homologyPrimeDecomposition}, ${sfs.homologyIsDirectDouble}")
          //println(sfs.complementaryEmbsWithPartitions.head)
          //println(tree.complementaryEmbeddings)
          //embeddings.foreach { println _ }
          //println(tree.muBarCompatComplementaryEmbs)
            sfsWhichPass = sfsWhichPass :+ sfs.toPythonString
          //}
        }
      }
    }
    println("Vector(" + sfsWhichPass.mkString(",") + ")")
    }

    /*
    SFSOverS2.generateSFSs(fibers=3, upper=15, e0 = 2)
      .filter(sfs => {
        val s = sqrt(sfs.homologyOrder).round.toSafeLong
        s*s == sfs.homologyOrder && sfs.homologyOrder > 0
      })
      .filter(_.isNegativeDefinite)
      .filter(_.homologyIsDirectDouble)
      //.filter(_.isLSpace)
      //.distinct
      .filter(sfs => {
          val s = sqrt(sfs.homologyOrder).round.toSafeLong
          val n = sfs.dInvariants.raw.count(_ == 0)
          n >= 2*s - 1
      })
      .foreach { sfs =>
      println(s"$sfs h1: ${sfs.homologyPrimeDecomposition}, ${sfs.homologyIsDirectDouble}")
      println(sfs.dInvariants.raw.count(_ == 0))
    }*/
    
    //println(Matrix(Vector(Vector(3,0,0),Vector(0,2,-1),Vector(0,-1,2))).extendedSmithForm)
    //val sfs = SFSOverS2(-1, Vector(r"-3", r"-4", r"-5/2"))
    //sfs.toTree.latticeEmbeddings(Some(5)).foreach{ println _ }
    //val embs = SFSEmbeddings(SFSOverS2(-2, Vector(r"-5/3", r"-5/2", r"-7/4")))
    //println(embs.exists(_.toMatrix.isSurjective))
    //embs.foreach { println }

    /*
    val emb = Matrix(Vector(
      Vector(1, -1, 0, 0, 0, 0),
      Vector(-1, 0, 1, 0, 0, 0),
      Vector(0, -1, 0, 1, 0, 0),
      Vector(-1, 0, -1, 0, 1, 0),
      Vector(0, -1, 0, -1, 0, 1)))

    emb.multiply(emb.transpose).smithNormalForm().mat.foreach { println }
     */

    /*
    import MontesinosIntersectionForm._

    val embedding = 
      Embedding(Node(-2, Vector()),
        Vector(
          Vector(Node(-2, Vector()), Node(-2, Vector()), Node(-3, Vector())),
          Vector(Node(-4, Vector()), Node(-2, Vector())),
          Vector(Node(-2, Vector()), Node(-2, Vector()), Node(-2, Vector()))
        ))
    
    MontesinosIntersectionForm.embeddings(embedding)
      .foreach { println(_) }

    //println(linearChain(9,-7))
    val sfs = SFSOverS2(1, Vector(r"8", r"8", r"8/7"))
    println(sfs.stdForm)
    val embs = SFSEmbeddings(sfs)
    println(embs)
    //println(embs.exists(_.toMatrix.isSurjective))
    //println(Vector((2,1)).dot(Vector((3,1))))
    //println(enumCoeffs(Vector(1, 3, 5, 7, 8, 9, 10, 11), 20).length)
    val mat = Matrix(Vector(Vector(0,4),Vector(-2,0)))
    println(mat.invariantFactors)
     */
    import IntersectionForm._
    import Tree.{tree => t, rationalChain => rat, _}

    val e8 =
      t(-2,
        t(-2),
        t(-2, t(-2)),
        t(-2, t(-2, t(-2, t(-2)))))

    //tr2.latticeEmbeddings.foreach { println }
    //println(tr2.isNegativeDefinite)
    //println(tr2.isLSpace)
    //println(tr2)
    //val tr3 = t((0 until 100000).toVector, t((0 until 100000).toVector))
    //tr3.enumerate.take(10).toVector.foreach { println }
    //println(tr2.latticeEmbeddings.head)
    //println(tr2.latticeEmbeddings.head.toMatrixTranspose)
    val r = (-3 to -2).toVector
    val tr3 =
      t(Vector(-2),
        t(r),
        t(r),
        t(Vector(-3),
          t(r),
          t(r)))
    /*
    for (t <- tr3.enumerate if t.isNegativeDefinite) {
      println(t)
      //println("Negative definite: " + t.isNegativeDefinite)
      println("Greene obstructs: " + t.greeneObstructs)
      println("Is LSpace: " + t.isLSpace)
//      t.latticeEmbeddings.foreach { println }
     }*/

    val tr5 =
      t(-2,
        t(-2),
        t(-2),
        t(-3,
          t(-2),
          t(-2)))
     val tr6 =
      t(-2,
        t(-3, t(-2)),
        t(-2),
        t(-3
          ,t(-3, t(-2))
          ,t(-2, t(-2))
        ))

    //println(t(-2, rat(r"-5/3"), rat(r"-3/2"), rat(r"-5/2")).isLSpace)
    /*
    var count = 0
    val upper = 5
    for (p1 <- 2 to upper;
      p2 <- 2 to upper;
      p3 <- 2 to upper;
      p4 <- 2 to upper;
      q1 <- 2 until p1 if gcd(p1,q1) == 1 && p1 > q1;
      q2 <- 2 until p2 if gcd(p2,q2) == 1 && p1*q2 <= p2*q1 && p2 > q2;
                                            //p1/q1 <= p2/q2
      q3 <- 1 until p3 if gcd(p3,q3) == 1 && p3 > q3;
      q4 <- 1 until p4 if (gcd(p4,q4) == 1 && p3*q4 <= p4*q3 && p4 > q4)) {
                                         // p2/q2 <= p3/q3
        val t1 = Rational(-p1, q1)
        val t2 = Rational(-p2, q2)
        val t3 = Rational(-p3, q3)
        val t4 = Rational(-p4, q4)
        val tree =
        t(-2, rat(t1), rat(t2),
          t(-3, rat(t3), rat(t4)))
      val cond = { // if this also holds then we're QA (provided taking r4 = -1
                   // gives a neg def plumbing, which is automatic)
        val tt3 = Rational(2*p3-q3, p3)
        val r3 = Rational(2*p3-q3, p3-q3)
        val r1 = Rational(p1, p1 - q1)
        val r2 = Rational(p2, p2 - q2)
          ((tt3 > Vector(r1,r2).min) || (-t2 > Vector(r3, r1).min)
        || (-t1 > Vector(r3, r2).min)) //&& (!(-t2 > r1 || -t1 > r2))
      }
      count += 1
      if (count % 100 == 0)
        println(count)
      if (tree.isNegativeDefinite &&
        //(1+1/t2)*(3+1/t3+1/t4) <= 1 && !cond &&
        !tree.isVerifiedQA &&
        tree.isLSpace == Right(true) &&
        !tree.greeneObstructs
      ) {
        // if we reach here we can't determine if QA one way or another

          println((t1,t2,t3,t4))
          println(tree)
          println("Negative definite: " + tree.isNegativeDefinite)
          println("Greene obstructs: " + tree.greeneObstructs)
        println("Is LSpace: " + tree.isLSpace)
          println("Is definitely QA: " + tree.isVerifiedQA)
          println((1+1/t2)*(3+1/t3+1/t4))
          //System.exit(1)
        }

      }
     
     
     */
    
    //val tree = t(-9, t(-10, t(-2, t(-4, t(-2, rat(r"-7/4")), t(-2)), t(-7), t(-3, t(-2), t(-2)))))
    //val tree = t(-2, rat(r"-5/3"), rat(r"-3/2"), rat(r"-5/2"))
    /*
        val t1 = r"-3/2"
        val t2 = r"-3"
        val t3 = r"-3/2"
        val t4 = r"-3/2"

    val (a1, a2, a3, a4, a5, a6) = (-2,-2,-3,-3,-3,-3)
    val tree2 = t(-2, t(-4, t(a1), t(a2)),
      t(-3, t(a3), t(a4)),
      t(-3, t(a5), t(a6)))
    val tree7 = t(-1, t(2, t(3)),
      t(-2, rat(r"3/2"), t(-3)),
      t(-3, t(-3), t(-3)))
    val tree6 = t(-2, t(-3),
      t(-2, t(-3), rat(r"3/2")),
      t(-2, t(a5), rat(r"3/2")))
    val tree4 = t(-2, t(-3), t(2, t(2)), t(-3))
    val tree5 = t(-2, t(-2, t(2), t(2)),
      t(-1, t(2, t(2)), t(2, t(2))),
      t(-2, t(-3), t(2, t(2))))
    //val tree = t(-3, rat(r"-21/5"), rat(r"-8/7"))
    val tree3 = t(-4, rat(r"-5"), rat(r"-3/2"))
    val tree8 = t(-3, t(-2), t(-3), rat(r"-4/3"), rat(r"-5/3"))
     */
    //println(tree)
    //println("Split: ")
    //tree.split(_ == -4).foreach { println }
    //tree.candidateQA(1)._3.foreach{println}
    //println(tree.toIntersectionForm.det)
    /*
    println(tree.isLSpace)
    println("Greene obstructs: " + tree.greeneObstructs)
    tree.latticeEmbeddings(Some(8)).foreach { println }
    println("end")

    IntersectionForm(Vector(
      Vector(-17,15,0),
      Vector(15,-19,0),
      Vector(0,0,-98))).embeddings(Some(3)).foreach{println}
     */
    /*
    tree
      .toIntersectionForm
      .directSum(IntersectionForm(Vector(Vector(-98))))
      .embeddings(Some(9))
      .foreach{println}
     */
    //tree.candidateQA.foreach { println }
    //println("Verified QA: " + tree.isVerifiedQA)
    
//    tree.detAddableNodes.foreach { x => println(x._1) }
    //println(tree.toIntersectionForm.toMathematica)

    //println(t(-2, rat(r"-3/2"), rat(r"-2"),
    // t(-3, rat(r"-2"), rat(r"-2"))).greeneObstructs)

    //tr4.latticeEmbeddings.foreach { println }
    //println(t(-2, t(-3, t(-2), t(-2)), t(-2)).toIntersectionForm)

    //tr3.enumerate.foreach { println }
    //println((0 to 500).map(i => (i, i.toChar)))


    /****** BEGIN
    // guarantee that there's no nice embedding
    def guarNotEmbed(t1: Rational, t2: Rational, t3: Rational, t4: Rational) = {
      (-1/t1 - 1/t2 >= 1) &&
      ((-1/t2 - 1/(-3 - 1/t3)) >= 1 ||
      (-1/t2 - 1/(-3 - 1/t4)) >= 1 ||
      ((-1/t2 - 1/t4) >= 1 ||
        (-1/t2 - 1/t3) >= 1 ||
        (-1/t3 - 1/t4) >= 1))
    }


    var count = 0
    val upper = 6
    for (p1 <- 2 to upper;
      p2 <- 2 to upper;
      p3 <- 2 to upper;
      p4 <- 2 to upper;
      q1 <- 1 until p1 if gcd(p1,q1) == 1 && p1 > q1;
      q2 <- 1 until p2 if gcd(p2,q2) == 1 && p1*q2 <= p2*q1 && p2 > q2;
                                            //p1/q1 <= p2/q2
      q3 <- 1 until p3 if gcd(p3,q3) == 1 && p3 > q3;
      q4 <- 1 until p4 if (gcd(p4,q4) == 1 && p3*q4 <= p4*q3 && p4 > q4)) {
                                         // p2/q2 <= p3/q3
      val t1 = Rational(-p1, q1)
      val t2 = Rational(-p2, q2)
      val t3 = Rational(-p3, q3)
      val t4 = Rational(-p4, q4)
      val tree =
        t(-2, rat(t1), rat(t2),
          t(-3, rat(t3), rat(t4)))
      val cond = { // if this also holds then we're QA (provided taking r4 = -1
                   // gives a neg def plumbing, which is automatic)
        val tt3 = Rational(2*p3-q3, p3)
        val r3 = Rational(2*p3-q3, p3-q3)
        val r1 = Rational(p1, p1 - q1)
        val r2 = Rational(p2, p2 - q2)
          ((tt3 > Vector(r1,r2).min) || (-t2 > Vector(r3, r1).min)
        || (-t1 > Vector(r3, r2).min)) //&& (!(-t2 > r1 || -t1 > r2))
      }
      count += 1
      if (count % 100 == 0)
        println(count)
      if (tree.isNegativeDefinite &&
        (1+1/t2)*(3+1/t3+1/t4) <= 1 && !cond && // can't guarantee QA
        !guarNotEmbed(t1,t2,t3,t4)
      ) {
        // can't prove either way
          println((t1,t2,t3,t4))
          println(tree)
          println("Negative definite: " + tree.isNegativeDefinite)
          println("Greene obstructs: " + tree.greeneObstructs)
          println("Is LSpace: " + tree.isLSpace)
          println((1+1/t2)*(3+1/t3+1/t4))
      }
    }
     */
    
    import scala.collection.immutable.{Vector => v}
    //val q = IntersectionForm(v(v(-11,2,0,0,0),v(2,-2,1,0,0),v(0,1,-2,0,0),v(0,0,0,-13,1),v(0,0,0,1,-2)))
    /*
    val q = IntersectionForm(v(
      v(-13,2,0,0,0,0),
      v(2,-2,1,0,0,0),
      v(0,1,-2,1,0,0),
      v(0,0,1,-2,1,0),
      v(0,0,0,1,-2,0),
      v(0,0,0,0,0,0,-49)
     ))
    val q = IntersectionForm(v(
      v(-5,8,0,0),
      v(8,-13,0,0),
      v(0,0,-1,1),
      v(0,0,1,-2)
    ))
     */
    /*
    val q = IntersectionForm(
      Vector(Vector(-2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Vector(1, -2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0), Vector(0, 1, -2, 1, 0, 0, 0, 0, 0, 0, 0, 0), Vector(0, 0, 1, -2, 1, 0, 0, 0, 0, 0, 0, 0), Vector(0, 0, 0, 1, -2, 1, 0, 0, 0, 0, 0, 0), Vector(0, 0, 0, 0, 1, -5, 0, 0, 0, 0, 0, 3), Vector(0, 0, 0, 0, 0, 0, -2, 1, 0, 0, 0, 0), Vector(0, 0, 0, 0, 0, 0, 1, -2, 1, 0, 0, 0), Vector(0, 0, 0, 0, 0, 0, 0, 1, -2, 1, 0, 0), Vector(0, 0, 0, 0, 0, 0, 0, 0, 1, -2, 1, 0), Vector(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -2, 1), Vector(0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, -3))
        )

    q.embeddings(Some(q.rank + 2)).foreach { println }
    println(q.toMatrix.absDet)
     */
    /*
    println(Matrix(v(v(-3,-1,0,-1), v(-1,-3,-1,0), v(0,-1,0,2), v(-1,0,2,0))).invariantFactors)
    println(Matrix(v(
      v(0,2,0,0,-1),
      v(2,0,-1,0,0),
      v(0,-1,3,-1,0),
      v(0,0,-1,3,-1),
      v(-1,0,0,-1,3))).invariantFactors)

    println(Matrix(v(
      v(5,-1,-1,-1,-1),
      v(-1,0,-1,0,0),
      v(-1,-1,3,-1,0),
      v(-1,0,-1,3,-1),
      v(-1,0,0,-1,3))).invariantFactors)
     */
    /*
    println(IntersectionForm(v(
      v(-3,1,0,0,1),
      v(1,-3,1,0,1),
      v(0,1,-2,-1,-1),
      v(0,0,-1,-2,-1),
      v(1,1,-1,-1,-3)
    )).embeddings(Some(6)))

    println(Matrix(v(
      v(-3,1,0,0,1),
      v(1,-3,1,0,1),
      v(0,1,-1,1,0),
      v(0,0,1,2,1),
      v(1,1,0,1,-2)
    )).invariantFactors)
     */
    /*
    val q = IntersectionForm(v(
      v(-3,3,0,0),
      v(3,-12,0,0),
      v(0,0,-14,1),
      v(0,0,1,-2)
     ))*/

    /*
    val q = IntersectionForm(v(
      v(-13,0,0),
      v(0,-7,1),
      v(0,1,-2)
    ))

    println(q.embeddings(Some(3)))
    println(LensSpace.dInvariants(13, 1).sorted)
    println(LensSpace.dInvariants(13, 10).sorted)
    println(LensSpace.dInvariants(13, 12).sorted)
    println(Vector(
      r"3/13",
r"-17/13",
r"-1/13",
r"1/13",
r"-9/13",
r"-17/13",
r"-3/13",
r"-3/13",
r"-1/13",
r"1/13",
r"-1",
r"3/13",
r"-9/13").map(r => -r).sorted)
     */
    //val latticeEmbeddings = q.embeddings
    //println(latticeEmbeddings.forall(m => !m.toMatrixTranspose.isSurjective))
    /*
    val Q = Matrix(v(
        v(3,-1,-1,1,1,-1),
        v(-1,2,-1,0,0,0),
        v(-1,-1,3,0,0,0),
        v(1,0,0,2,1,0),
        v(1,0,0,1,2,0),
        v(-1,0,0,0,0,2)))
    println((Q*2).rowReduced())

    println(Q* -1)
     */
    //DInvariants.sfs(-2, Vector(r"2", r"3/2", r"9/4")).foreach{println}
    //println(LensSpace.dInvariants(4, 3))
    //val dInvs = DInvariants.sfs(-2, Vector(r"5/4", r"7/3", r"2"))
    //println("Homology: " + dInvs.homology)
    //dInvs.dInvs.foreach { println }
    //println(DInvariants.alexPoly(Vector(-2), 1))
    //println(DInvariants.possibleAlexPoly(Vector(2), -1))
    //println(SFSOverS2(-2, Vector(r"-2", r"-3/2", r"-5/4")).alexPolyFromSurgery(-1))
    //println(DInvariants.possibleAlexPoly(dInvs.dInvs.map(-_._1), dInvs.homology(0)))

    //println(LensSpace.dInvariants(3, 2).sorted)
    //println(DInvariants.sfs(-2, Vector(r"2", r"7/4", r"13/12")))
    //println(DInvariants.sfs(-2, Vector(r"4/3", r"13/4", r"17/16")))
    //println(DInvariants.sfs(-1, Vector(r"2/1", r"3/1", r"8/1")))
      //[-1,1,2,1,3,1,8]
    //  [(2, -1), (7, 3), (13, 1)]
    // [(4, 1), (13, -4), (17, 1)]
    //println(DInvariants.toContinuedFraction(r"5/3"))
    //println(DInvariants.fromContinuedFraction(Vector(2,2,2)))


   
    //val sfs = SFSOverS2(3, Vector(r"2", r"3", r"4/3", r"5/3"))
    /*
    val sfs = SFSOverS2(0, Vector(r"2", r"-3", r"3"))
    println("isNegativeDefinite: " + sfs.isNegativeDefinite)
    println("isTorisu: " + sfs.isTorisuForm)
    println("homology: " + sfs.homologyOrder)
    println(sfs.alexPolyFromSurgery(Rational(-sfs.homologyOrder, 2)))
    println(sfs.alexPolyFromSurgery(Rational(sfs.homologyOrder, 2)))
    //println(sfs.alexPolyFromSurgery(Rational(sfs.homologyOrder, 1)))
    //println(sfs.alexPolyFromSurgery(Rational(-sfs.homologyOrder, 1)))
    println("L(9,2): " + LensSpace.dInvariants(9,2))
    println("SFS: " + sfs.dInvariants.raw)
     */

    /*
    IntersectionForm(v(
      v(-12,-10,-10),
      v(-10,-13,-10),
      v(-10,-10,-13)
    ))
      .embeddings(Some(4))
    .foreach { println }
     */

    //println("L(8,1): " + LensSpace.dInvariants(8,1).sorted)
    //println("SFS: " + SFSOverS2(1, Vector(r"2", r"2", r"3/2")).dInvariants.raw.sorted)
    //println(SFSOverS2(-4, Vector(r"-2", r"-2", r"-3/2", r"-3/2", r"-5/2")).homology)

    /*
    println("Possible alex poly: " +
      DInvariants.possibleAlexPoly(LensSpace.dInvariants(43,6), r"43/2"))

    println("SFS dinv: " + sfs.dInvariants.raw.sorted)
    println("L(43,6): " + LensSpace.dInvariants(43,6).sorted)
     */


    //val sfs = SFSOverS2(-4, Vector(r"-2", r"-3/2", r"-3", r"-4"))
    //val sfs = SFSOverS2(-2, Vector(r"2", r"3", r"-3", r"-4"))
    //println(sfs.alexPolyFromSurgery(Rational(sfs.homologyOrder, 1)))
    //val tree = t(-4, rat(r"-2"), rat(r"-3/2"), rat(r"-3"), rat(r"-4"))
    //tree.toIntersectionForm.directSum(IntersectionForm(Vector(Vector(-162))))
    //  .embeddings(Some(7)).foreach { emb => println(emb) }
    //println(tree.toIntersectionForm)
    //println(tree.toIntersectionForm.toMatrix.smithNormalForm())
    //println(IntersectionForm.vectorsOfNorm(162, 7).length)
    //tree.latticeEmbeddings(Some(7)).foreach { println }
    //println(sfs.dInvariants)
    /*
    println(tree)
    println("neg def: " + tree.isNegativeDefinite)
    println("LSpace: " + tree.isLSpace)
    println("Homology: " + tree.toIntersectionForm.det)
    
    tree.toIntersectionForm.directSum(IntersectionForm(v(
      v(-64)))).embeddings(Some(7)).foreach { println }
     */

    /*
    SFSOverS2.generateSFSs(4, 5, 1)
      .filter(sfs => sfs.homologyOrder != 0 && sfs.homology.length == 1)
      .distinct
      .map(_.negDef)
      .foreach { println }
     */
    /*
    val sfs = SFSOverS2(-2, Vector(r"-3/2", r"-3/2", r"-2"))
    println(sfs.alexPolyFromSurgery(Rational(sfs.homologyOrder, 2)))
    println(sfs.dInvariants)
    println(LensSpace.dInvariants(3,2).map(-_))
    println(sfs.homology)
     */
    /*
    SFSOverS2.generateSFSs(fibers=3, upper=7, e0=2)
    //Stream.continually(SFSOverS2.randomSFS(fibers=3, upper=100, e0=2))
      .filter(sfs => sfs.homology.length == 1 && sfs.isQA && sfs.homologyOrder <= 300)
      .map(_.negDef.stdForm.sortParams)
      .distinct
      .take(100)
      .foreach { sfs =>
      if (!sfs.canObstructSurgery(Rational(-sfs.homologyOrder, 2))) {
        println(s"$sfs, TorisuForm: ${sfs.isTorisuForm}, homology: ${sfs.homologyOrder}")
      }
    }*/

    /*
    import java.io._
    val pw = new PrintWriter(new File("C:/Users/Ahmad/Dropbox/code/HF_Homology/qa_u1_mont.txt"))
    //SFSOverS2.generateSFSs(fibers=3, upper=9, e0= 2)
    Stream.continually(SFSOverS2.randomSFS(fibers=3, upper=100, e0=2))
      .filter(sfs => sfs.homologyOrder >= 1 && sfs.homologyOrder <= 300 && sfs.isQA &&
        sfs.homology.length == 1 && sfs.plumbingRank < 11)
      .map(_.negDef.stdForm.sortParams)
      .distinct
      .take(1000)
      .foreach { sfs =>
      /*
      println(sfs)
      println(sfs.toTree)
      sfs.toTree.perpEmbedding(
                IntersectionForm(Vector(Vector(-2))), Some(sfs.plumbingRank+2)).foreach {
                case (tree, emb) => {
                  println(tree)
                  println(emb)
                }                  
              }
       */
        val cantObstruct =
          !sfs.canObstructSurgery(Rational(sfs.homologyOrder, 2))

          if (cantObstruct) {
            println(s"$sfs : TorisuForm? ${sfs.isTorisuForm}")
            println(s"homology: " + sfs.homology)
            pw.println(s"$sfs : TorisuForm? ${sfs.isTorisuForm}")
            pw.println(s"homology: " + sfs.homology)

            val cms = sfs.toTree.halfIntCMEmbeddings
            if (cms.isEmpty) {
              val obstOpposite = sfs.canObstructSurgery(Rational(-sfs.homologyOrder, 2))
              pw.println("No changemaker embeddings. Can obstruct opposite: " + obstOpposite)
            } else {
              val cm = cms(0)
              println(cm.pretty)
              println()
              println("cm basis: " + cm.stdBasisRows)
              println("vert basis: " + cm.vertexBasisRows)
              val p = cm.cmBasisToVertexBasis
              println(p)
              println(cm.tree.toLabelledTree)
              /*
              sfs.toTree.perpEmbedding(
                IntersectionForm(Vector(Vector(-2))), Some(sfs.plumbingRank+2)).foreach {
                case (tree, emb) => {
                  println(tree)
                  println(emb)
                }                  
              }*/

              //require(
              //  p.mat.map(row => row.count(i => abs(i) > 1)).sum < 2, "Bad")
              pw.println(cm.pretty)
              pw.println()
              pw.flush()
              /*
              val cm = cms(0)
              println(s"cm basis: ${cm.stdBasisRows}")
              println(s"vertex basis: ${cm.vertexBasisRows}")
              println(cm.tree.toLabelledTree)
              println(cm.cmBasisToVertexBasis)
               */
            }
            //println(sfs.alexPolyFromSurgery(Rational(-sfs.homologyOrder, 1)))
            //println(sfs.alexPolyFromSurgery(Rational(sfs.homologyOrder, 1)))
          }
    }
    pw.flush()
    pw.close()
    */

    //println(SFSOverS2(2, Vector(r"2", r"3", r"3")).toTree.toIntersectionForm)
    //println(SFSOverS2.randomSFS(fibers=3, upper=15, e0=2))

    /*
    SFSOverS2.generateSFSs(fibers=5, upper=5, e0 = 0)
      .filter(sfs => sfs.homologyOrder <= 700 && sfs.isLSpace &&
        sfs.homology.length == 1)
      .map(_.negDef.sortParams)
      .distinct
      .foreach { sfs =>
        val cantObstruct =
         !sfs.canObstructSurgery(Rational(sfs.homologyOrder, 1))

         
          if (cantObstruct) {
            println(s"$sfs")
            println(s"homology: " + sfs.homology)
            //println(sfs.alexPolyFromSurgery(Rational(sfs.homologyOrder, 1)))
            val cms = sfs.toTree.changemakerEmbeddings
            cms.find({ emb => !emb.markedCrossing.isEmpty }) match {
              case Some(emb) => {
                println(emb)
                println(emb.markedCrossing)
              }
              case None => {
                println("No marked crossing: ")
                println(cms.head)
              }
            }
          }
     }*/
    /*
    import Changemaker._
    val folder = "C:/Users/Ahmad/Dropbox/code/HF_Homology/data/pairing_graphs/"
    SFSOverS2.generateSFSs(fibers=4, upper=7, e0 = -1)
      .filter(sfs => sfs.homologyOrder <= 500 && sfs.homologyOrder > 0 &&
        sfs.homology.length == 1)
      .map(_.negDef.sortParams)
      .distinct
      .foreach { sfs =>
        if (!sfs.canObstructSurgery(Rational(sfs.homologyOrder, 1))) {
        val cms = sfs.toTree.changemakerEmbeddings
        if (cms.length > 0) {
          println(s"$sfs")
          println(s"homology: " + sfs.homology)
          println(s"cm: " + cms(0).cmRaw)
          val cm = cms(0).cmRaw
          println(stdBasisRows(cm))

          /*
          if (cms(0).overlapsAtCentral) {
            println(cms(0))
            println(cms(0).cmBasis)
            println("breakable:")
            println(cms(0).breakableIndices
              .map(i => Changemaker.breakTight(cms(0).cmRaw, i)))
            
            println("Pairing graph: " + cms(0).pairingGraph)
            val filename = folder + sfs.toString.replace("/", "q") + ".png"
            Mathematica.graphToFile(cms(0).pairingGraph, filename)
            //sys.exit(1)
          }*/
          //require(cms(0).cmBasis.mat(0).exists(_ == 2), "Doesn't have tight vector.")
        }
        }
      }
     */

    //println(SFSOverS2(0, Vector(r"-2", r"3", r"10")).toTree.toIntersectionForm)
    //  .negDef.toTree.latticeEmbeddings().foreach { println }
    //SFSOverS2(1, Vector(r"2", r"3", r"10")).dInvariants.dInvs .foreach{ println }
    //println(LensSpace.dInvariants(9, 1))
    /*
    import Graph._
    import Changemaker._
    val folder = "C:/Users/Ahmad/Dropbox/code/HF_Homology/data/cm_pairing_graphs/"
    var counter = 0
    var numComps = 1
    for (h1 <- 800 to 1000) {
      if (h1 % 10 == 0)
        println("h1 = " + h1)
      for (parts <- 12 to 12;
        cm <- Changemaker.changemaker(h1, parts)) {
        if (tightIndices(cm).length == 1) {
          val i = tightIndices(cm)(0) - 1
          (0 until parts).combinations(1).foreach { case Vector(j) =>
            if (j != i) {
              val pg = Changemaker.pairingGraph(cm)
              val breakable = breakTight(cm, i+1)
              val basis = stdBasis(cm).transpose
              for ((x, y) <- breakable) {
                val adj_pg = pairingGraph(basis.replaceRow(i, x.map(SafeLong(_))))
                
                val n = numberOfComponents(removeVertex(adj_pg, j))
                  //numberOfComponents(adj_pg)                  

                if (n > numComps || adj_pg(i).qsum == 0) {
                  numComps = max(n, numComps)
                  println("num comps: " + n)
                  val filename = folder + cm.toString + ".png"
                  println(filename)
                  counter += 1
                  println(s"v_${i+1} is tight. removed v_${j+1}")
                  //println(s"x=$x, y=$y, z=$z")
                  println(removeVertex(adj_pg, j))
                  //println(s"i,j = $i,$j")
                  Mathematica.graphToFile(adj_pg, filename)
                }
              }
            }
          }
        }
      }
    }*/
    
    //Changemaker.xform2(5, 8).foreach{x => println(x.reverse)}
    //println(Changemaker.expressInStdBasis(Vector(1,1,1,4,4,9,12), Vector(2,0,2,-1,0,0,0)))
    /*
    val cm = Vector(1, 1, 2, 3, 3, 4, 15, 15, 19, 23)
    println(cm)
    println(Changemaker.breakTight(cm, 6))
     */
    //println(Changemaker.stdBasisRows(cm))
    //println(SFSOverS2(-4,Vector(r"-7/2", r"-2", r"-3/2", r"-7/5")).toTree)

    /*
    SFSOverS2.generateSFSs(fibers=3, upper=7, e0=1)
      .filter(sfs => !sfs.isKnownTQA)
      .map(_.sortParams)
      .distinct
      .foreach { sfs =>
      val c = sfs.coeffs.map(r => (r.numerator, r.denominator)) :+ (1, -sfs.e0)
      println(c.toString + ",")
     }*/
    //(3, 2), (7, 2), (4, 1), (-1, 1)
   // println(SFSOverS2(1, Vector(r"3/2", r"7/2", r"4/1")).homologyOrder)
    //println(SFSOverS2(1, Vector(r"5/2", r"5/3", r"2")).isQA)

    //println(SFSOverS2(0, Vector(r"-2/3", r"3/1", r"4/2", r"5/2", r"7/1")).dInvariants)
    //val sfs = SFSOverS2(4,Vector(r"3/2", r"4/3", r"11/9", r"13/12", r"19/16"))

    /*
    for (p1 <- 2 until 20;
      p2 <- 2 until p1;
      p3 <- 2 until p2;
      p4 <- 2 until p3;
      p5 <- 2 until p4) {
      val multiplicities: Vector[SafeLong] = Vector(p1,p2,p3,p4,p5)
      val coprime = multiplicities.combinations(2).forall({ case Vector(a, b) => gcd(a, b) == 1 })

      if (coprime) {
        val sfs = SFSOverS2.brieskorn(multiplicities)
        if (sfs.negDef.e0 == -1)
          println(s"$sfs : ${sfs.dInvariants.raw}")
      }
    }
     */

    //println(SFSOverS2.generateSFSs(fibers=5, upper=8, e0 = 4).length)
    /*
    val sfs = SFSOverS2(-6, Vector(r"-2", r"-2", r"-3", r"-3"))
    sfs.toTree.changemakerEmbeddings.foreach { emb =>
      println(emb)
      //println(emb.hasMarkedCrossing)
     }*/
    //IntersectionForm.vectorsOfNormAtMost(6, 2).foreach { println }
    //println(sfs.toTree.changemakerEmbeddings.exists { emb => emb.hasMarkedCrossing })
    //IntersectionForm.changemakerEmbedding(sfs.toTree.toIntersectionForm).foreach { println }
  }
}
